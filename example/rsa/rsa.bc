; ModuleID = 'rsa.bc'
target datalayout = "e-m:x-p:32:32-i64:64-f80:32-n8:16:32-a:0:32-S32"
target triple = "i686-pc-windows-msvc16.0.0"

%struct.rsa_pk_t = type { i32, [256 x i8], [256 x i8] }
%struct.rsa_sk_t = type { i32, [256 x i8], [256 x i8], [256 x i8], [128 x i8], [128 x i8], [128 x i8], [128 x i8], [128 x i8] }
%struct._iobuf = type { i8*, i32, i8*, i32, i32, i32, i32, i8* }
%struct._SECURITY_ATTRIBUTES = type { i32, i8*, i32 }

@key_m = global [256 x i8] c"\B8\9Bc\7F3\EE\AD\06\18\9F\F1]\9D\C7\B8\E9\ADM7%\1F0\A4\BE=\C7\12\E9j\84\BC\AB6m\E8\12>\12\DD\0D\C3q\1E\0E*\BDWs\D4\D7\CDH\A0d\F9X\07H\DAI\80\A8\93`\AEt\A2m\96xfJ\D5\A0A\AA\A1<\10q\D3.\89\8E\0A\AC\F0\04\16t\AD\BF\7FP\B7\1C\9D\84\9D|\DC\AB\03\AC\D7h\B6Y\8C\15H\BA\07\A7\90\89\A9v\E2x\B5\E6\19\E3\C5\CD\C0\A1)\22$\D5B\B9\E3]\F7b\00\8ByV\BF?\E3v.g\EB\C3v\F8\ADt\1E\93\93\B5/\917\91\E2\D2\90J\B0\EF%x|\9A\06\D6\D1\C3LI*\F7\12\80\16b\0B\D4\A2\96\9F\1E9\FA)\A2\D9\1A\0E\0DdS\82)\18\8AYW\B0\ED\AD\F0\8E\17Z\9C\B6\A0\C7\96\C8M\1Eq\B2\1Cl\F0\95\FC\E6\C7\90I\04\F2\01\A7\8A\C4J\D4\95\FF\15k\A04 \FE\86\BBp\CC\AC\A9\C1\A7", align 1
@key_e = global [3 x i8] c"\01\00\01", align 1
@key_pe = global [256 x i8] c"\B6\96ZN\91\DA\DB\9FO\F3\C2\12\C9\DF\A4p\DBK\A7\E3;z-7Lz\FD\A5\88\09Ib>/n}\BC\8F\83\BB\FD6\80w\9A\A63=\09\A3x\13\011]\BDGW3/\C7\E4\F3\FF\88\0D,*\1F\CDm\BFN\93v\DF\81!\9BR9\81\A9\E3\A7\83l\D1^4\815\0A\83\96\D8\E2\A3+\F17\80\9D\DD\F2 K[>F>\EC`m\C7s\A0\FDH\FA\03OW\04\05\BC\7Fl7=\95\8A\06:\91a\1F\B5\06\FA\06?\03\D3\87\C6\C4\B5\C4\B3\99\E0\18\8B1=\00Y\E8\F9\A25SHFP\BB\E0V\D7\DF\92\E6\95g\09\D2\E5\F8\DF\A6\AC\99\C6(\89\10\C4\AF\0B?\D3\E4<\85\E5\137\8C\F7\B3\AF\C0\C6-\18\D2h\E1\1Fj#\E2X\CE&gyd\12i\AA\9DR\9E\BFW\DB\DD\DD\04\FB\C6\B1\FE\08\01Mk\87\18'\F19\94\1A\CF\EB\E6\FE\07\C3\FB\84z\A1", align 1
@key_p1 = global [128 x i8] c"\ED\89\0B\DC\BER\DC\0D1\9C?2\999\F3\8EV]\CB\D1Kz;\F8\A7ex\E9\AE%3\9C\0BR\EFL\97\DC\BF\92A\DC@\F6\82q\09\8E\FB4\9F\E7\13B)g\F0\EE\01\1ACJ\F3\EE\87w\F7\F0\DE\94\05\93\ACY\ADi\17,\01\1C\0F\1A(\D93\E1\E5\94\80\AE\B5\B9^\F9n`\07\A6\84R\12 \09 ~\8D\F5\19\DAS\F2\02\BF\F4\B5\0C\C3!\08\FF.$\D1\07p\1D\C9\0B", align 1
@key_p2 = global [128 x i8] c"\C6\F5\11k\CB\0C\05+\13@Mi\91\94\1BQ\B5n\E8\17{DR\B2\9B\1C=\E7\80E\C7\15\C0-\BD\E6d\83:\B4\F3/\95W\A2\00F\AE\D5\CF\FB\88\F1\F8\8E\83#\DCw\C1\E6\83;Nu\00#}\19\0E\0A`\9A\CE\F1V\B1\C0\C5G\F2?c\A2Z~\E9\00\0F\1C8\E3\17\A5\DCE\C9|W\ABh\8CH\1Ba\F4_{\A2\9C>\C4t\EF\C0\86E\F8\14j\9D\B1\F9\825\CC\A3U", align 1
@key_e1 = global [128 x i8] c">\02\BA\13\0D\A8\AA\03\D3\C0\BB\8A\E5\0F\88\F2\CE\BF;\D7N\C2\01g\FF\A3p\F6h]\13\E5\17\DB\B5\D7$\0A \04\F9\A6\9BZ\FF`\AD##\97pk-\CE\E6\EAX\AEy\A16\92\19\AEZ\B5J\08\1A\C3?\D5vx\0E\DAQ\8FNV\D9\E6ue\86\B2\E1qlJ\AF\ECM\CC\061\91\AD\B9\FB\86\F9\D0\08(\A1\BC\AB\DC p\1C\A1\AA+\9D\C2O\1C\7F)\B7\B8\CE\1DI\D9S", align 1
@key_e2 = global [128 x i8] c"\C5\09\E6S\F4\06\96\83\BF\90\1AZ\A8\03\9F>\BF\C9\F3\EFut\07\D6\BD\09.A\BCf\DE\B1*\DF\E2GoZ\0B\E53F\F7\C7\8F8h\C84\16\C3\CD/\9E\F3<\EBb'\F4\8F\9F~7\C8e\F7\BF\A7\F5\A0\CFe\E1\F7_\DD\B0\C5p\E8x`\EBdfu\C9J-\B0%/\C1b\B2v\C6?i\11\A4\84\B1!\C4\CC_|~\F3&\CB\8C\BA\06\00\FB\9C\F4\AD\F2\99\E1\9B\F8k\F5", align 1
@key_c = global [128 x i8] c"\CC\C6\BA\E9\80(\80\C6\C6u\9A`\B5@\0C8\B5oS\CD\AD%\13:U\8F\E3\17vo\F1\C3H:^c\07\AC\D0\C4\B4\BE\8BN3\00\97;@L\80F\1E\96\854'u\D1\E5\18\E0\11\F4\04\DD}\ADb\F0\FE\FC\D2\011\1E\22?\EC\BD-F\D9\C3Y\D2L4\F2\94\B9Ln3\88a0\0FwPEb\B1>s\F0\A2\EE\A9;\FE\E4.\C9\9A\F3\FCcBB\DF\B5x3qa+f", align 1
@hex_array = global [256 x i8] c"_\AFG\E5k<\B4\C2\E6\8D\F5\B6\89\BD\22\91\14\5C\97\C3\93\9C\D2\06\1A\82d\C6\CB\C1\F6A\9A\BB\84\E2\82]t\85\00V\8A\951~\9D\B9d\AD\CD\D1\99\DAL\CF\D6\94V^\95\E6\99 \19#U\CC\E7\DDzWi\9B]\ECN\07\F2\AE\C3v\F3\9F\A9\E2V\C8\D8\97\C6D\F8\BE,\22\9D;\8A\8D\D7@\9F%\96;\D9\C3\EF!\DEL,*\0C\D1>\06F\C3\B6\08\0F\BB\11\D8\B6d\FC\A1(\AA;\0E\CC\1E\C4Y\C8\A3\D7\C1\9FE\B9\ADd\07|\DEa\CB\A7\0FT\B7w\93S\DB8q\0E\D4n\C5\1A\96\0F\8A\14b3\B9E\82\10\AB\EE\9Dc\D7+\0C\09\E8\99\10\1C\10\F2\EB\22H\B1\A2G\C3\A0\CFuMK\CE\0Eo;d\7FR\09\02\FA;\15\DAH\89\9A\BD\D9~\96\93\CE\95\ABIn\22\A6\05\CAu\19T\FA\BB\DEX\9C1x\FAj\F9\19}t\08_\0F\E6\EEx\0C", align 1
@.str = private unnamed_addr global [9 x i8] c"%s[%d]: \00", align 1
@.str.1 = private unnamed_addr global [5 x i8] c"%02X\00", align 1
@.str.2 = private unnamed_addr global [2 x i8] c"\0A\00", align 1
@.str.3 = private unnamed_addr global [3 x i8] c"%s\00", align 1
@.str.4 = private unnamed_addr global [5 x i8] c"%02X\00", align 1
@.str.5 = private unnamed_addr global [2 x i8] c"\0A\00", align 1
@.str.6 = private unnamed_addr global [9 x i8] c"%s[%d]: \00", align 1
@.str.7 = private unnamed_addr global [5 x i8] c"%02X\00", align 1
@.str.8 = private unnamed_addr global [2 x i8] c"\0A\00", align 1
@.str.9 = private unnamed_addr global [9 x i8] c"PK[%d]:\0A\00", align 1
@.str.10 = private unnamed_addr global [12 x i8] c"  modulus: \00", align 1
@.str.11 = private unnamed_addr global [13 x i8] c"  exponent: \00", align 1
@.str.12 = private unnamed_addr global [9 x i8] c"SK[%d]:\0A\00", align 1
@.str.13 = private unnamed_addr global [12 x i8] c"  modulus: \00", align 1
@.str.14 = private unnamed_addr global [19 x i8] c"  public_exponet: \00", align 1
@.str.15 = private unnamed_addr global [13 x i8] c"  exponent: \00", align 1
@.str.16 = private unnamed_addr global [11 x i8] c"  prime1: \00", align 1
@.str.17 = private unnamed_addr global [11 x i8] c"  prime2: \00", align 1
@.str.18 = private unnamed_addr global [19 x i8] c"  primeExponent1: \00", align 1
@.str.19 = private unnamed_addr global [19 x i8] c"  primeExponent2: \00", align 1
@.str.20 = private unnamed_addr global [16 x i8] c"  coefficient: \00", align 1
@.str.22 = private unnamed_addr global [2 x i8] c"\0A\00", align 1
@.str.23 = private unnamed_addr global [30 x i8] c"rsa_generate_keys, ret: %04X\0A\00", align 1
@.str.24 = private unnamed_addr global [4 x i8] c"MSG\00", align 1
@.str.25 = private unnamed_addr global [7 x i8] c"PK ENC\00", align 1
@.str.26 = private unnamed_addr global [31 x i8] c"rsa_public_encrypt, ret: %04X\0A\00", align 1
@.str.27 = private unnamed_addr global [7 x i8] c"SK DEC\00", align 1
@.str.28 = private unnamed_addr global [9 x i8] c"DEC: %s\0A\00", align 1
@.str.29 = private unnamed_addr global [32 x i8] c"rsa_private_decrypt, ret: %04X\0A\00", align 1
@.str.30 = private unnamed_addr global [7 x i8] c"SK ENC\00", align 1
@.str.31 = private unnamed_addr global [32 x i8] c"rsa_private_encrypt, ret: %04X\0A\00", align 1
@.str.32 = private unnamed_addr global [7 x i8] c"PK DEC\00", align 1
@.str.33 = private unnamed_addr global [9 x i8] c"DEC: %s\0A\00", align 1
@.str.34 = private unnamed_addr global [31 x i8] c"rsa_public_decrypt, ret: %04X\0A\00", align 1
@.str.35 = private unnamed_addr global [2 x i8] c"\0A\00", align 1
@.str.36 = private unnamed_addr global [7 x i8] c"sk.prv\00", align 1
@.str.40 = private unnamed_addr global [2 x i8] c"w\00", align 1
@.str.41 = private unnamed_addr global [19 x i8] c"CAN NOT OPEN FILE\0A\00", align 1
@.str.37 = private unnamed_addr global [4 x i8] c"DEC\00", align 1
@.str.38 = private unnamed_addr global [9 x i8] c"DEC: %s\0A\00", align 1
@.str.39 = private unnamed_addr global [32 x i8] c"rsa_private_decrypt, ret: %04X\0A\00", align 1
@.str.42 = private unnamed_addr global [7 x i8] c"sk.prv\00", align 1
@.str.43 = private unnamed_addr global [4 x i8] c"DEC\00", align 1
@.str.44 = private unnamed_addr global [9 x i8] c"DEC: %s\0A\00", align 1
@.str.45 = private unnamed_addr global [32 x i8] c"rsa_private_decrypt, ret: %04X\0A\00", align 1
@.str.21 = private unnamed_addr global [23 x i8] c"result=%ld,time=%lf s\0A\00", align 1
@"\01?hMutexList@@3PAPAXA" = global [20 x i8*] zeroinitializer, align 4
@"\01?MutexFuncList@@3PAPAXA" = global [20 x i8*] zeroinitializer, align 4
@"\01?WhileEndFlag@@3PAHA" = global [20 x i32] zeroinitializer, align 4
@"\01?GlobalSignal@@3HA" = global i32 -1, align 4
@"\01?GlobalThreadID@@3HA" = global i32 -1, align 4
@"\01?thresholdForOthread@@3HA" = global i32 2, align 4
@"\01?threadNumForOthread@@3HA" = global i32 10, align 4
@"\01?FunctionGrgphForOthread@@3PAY0DOI@HA" = global [20 x [1000 x i32]] zeroinitializer, align 4
@"\01?totalnum@@3HA" = global i32 0, align 4
@"\01?CalcCallNumForOthread@@3PAY0DOI@HA" = global [20 x [1000 x i32]] zeroinitializer, align 4
@.str.46 = private unnamed_addr global [12 x i8] c"total = %d\0A\00", align 1
@.str.1.47 = private unnamed_addr global [10 x i8] c"%d-%d:%d\0A\00", align 1
@SMALL_PRIMES = constant [4 x i8] c"\03\05\07\0B", align 1
@.str.50 = private unnamed_addr global [2 x i8] c"r\00", align 1

; Function Attrs: noinline nounwind
define void @bn_decode(i32* %bn, i32 %digits, i8* %hexarr, i32 %size) #0 {
entry:
  %size.addr = alloca i32, align 4
  %hexarr.addr = alloca i8*, align 4
  %digits.addr = alloca i32, align 4
  %bn.addr = alloca i32*, align 4
  %t = alloca i32, align 4
  %j = alloca i32, align 4
  %i = alloca i32, align 4
  %u = alloca i32, align 4
  store i32 %size, i32* %size.addr, align 4
  store i8* %hexarr, i8** %hexarr.addr, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %bn, i32** %bn.addr, align 4
  store i32 0, i32* %i, align 4
  %0 = load i32, i32* %size.addr, align 4
  %sub = sub i32 %0, 1
  store i32 %sub, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc9, %entry
  %1 = load i32, i32* %i, align 4
  %2 = load i32, i32* %digits.addr, align 4
  %cmp = icmp ult i32 %1, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %3 = load i32, i32* %j, align 4
  %cmp1 = icmp sge i32 %3, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %4 = phi i1 [ false, %for.cond ], [ %cmp1, %land.rhs ]
  br i1 %4, label %for.body, label %for.end10

for.body:                                         ; preds = %land.end
  store i32 0, i32* %t, align 4
  store i32 0, i32* %u, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %5 = load i32, i32* %j, align 4
  %cmp3 = icmp sge i32 %5, 0
  br i1 %cmp3, label %land.rhs4, label %land.end6

land.rhs4:                                        ; preds = %for.cond2
  %6 = load i32, i32* %u, align 4
  %cmp5 = icmp ult i32 %6, 32
  br label %land.end6

land.end6:                                        ; preds = %land.rhs4, %for.cond2
  %7 = phi i1 [ false, %for.cond2 ], [ %cmp5, %land.rhs4 ]
  br i1 %7, label %for.body7, label %for.end

for.body7:                                        ; preds = %land.end6
  %8 = load i32, i32* %j, align 4
  %9 = load i8*, i8** %hexarr.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %9, i32 %8
  %10 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %10 to i32
  %11 = load i32, i32* %u, align 4
  %shl = shl i32 %conv, %11
  %12 = load i32, i32* %t, align 4
  %or = or i32 %12, %shl
  store i32 %or, i32* %t, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body7
  %13 = load i32, i32* %j, align 4
  %dec = add nsw i32 %13, -1
  store i32 %dec, i32* %j, align 4
  %14 = load i32, i32* %u, align 4
  %add = add i32 %14, 8
  store i32 %add, i32* %u, align 4
  br label %for.cond2

for.end:                                          ; preds = %land.end6
  %15 = load i32, i32* %t, align 4
  %16 = load i32, i32* %i, align 4
  %17 = load i32*, i32** %bn.addr, align 4
  %arrayidx8 = getelementptr inbounds i32, i32* %17, i32 %16
  store i32 %15, i32* %arrayidx8, align 4
  br label %for.inc9

for.inc9:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end10:                                        ; preds = %land.end
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc16, %for.end10
  %19 = load i32, i32* %i, align 4
  %20 = load i32, i32* %digits.addr, align 4
  %cmp12 = icmp ult i32 %19, %20
  br i1 %cmp12, label %for.body14, label %for.end18

for.body14:                                       ; preds = %for.cond11
  %21 = load i32, i32* %i, align 4
  %22 = load i32*, i32** %bn.addr, align 4
  %arrayidx15 = getelementptr inbounds i32, i32* %22, i32 %21
  store i32 0, i32* %arrayidx15, align 4
  br label %for.inc16

for.inc16:                                        ; preds = %for.body14
  %23 = load i32, i32* %i, align 4
  %inc17 = add i32 %23, 1
  store i32 %inc17, i32* %i, align 4
  br label %for.cond11

for.end18:                                        ; preds = %for.cond11
  ret void
}

; Function Attrs: noinline nounwind
define void @bn_encode(i8* %hexarr, i32 %size, i32* %bn, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %bn.addr = alloca i32*, align 4
  %size.addr = alloca i32, align 4
  %hexarr.addr = alloca i8*, align 4
  %t = alloca i32, align 4
  %j = alloca i32, align 4
  %i = alloca i32, align 4
  %u = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %bn, i32** %bn.addr, align 4
  store i32 %size, i32* %size.addr, align 4
  store i8* %hexarr, i8** %hexarr.addr, align 4
  store i32 0, i32* %i, align 4
  %0 = load i32, i32* %size.addr, align 4
  %sub = sub i32 %0, 1
  store i32 %sub, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc9, %entry
  %1 = load i32, i32* %i, align 4
  %2 = load i32, i32* %digits.addr, align 4
  %cmp = icmp ult i32 %1, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %3 = load i32, i32* %j, align 4
  %cmp1 = icmp sge i32 %3, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %4 = phi i1 [ false, %for.cond ], [ %cmp1, %land.rhs ]
  br i1 %4, label %for.body, label %for.end10

for.body:                                         ; preds = %land.end
  %5 = load i32, i32* %i, align 4
  %6 = load i32*, i32** %bn.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %6, i32 %5
  %7 = load i32, i32* %arrayidx, align 4
  store i32 %7, i32* %t, align 4
  store i32 0, i32* %u, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %8 = load i32, i32* %j, align 4
  %cmp3 = icmp sge i32 %8, 0
  br i1 %cmp3, label %land.rhs4, label %land.end6

land.rhs4:                                        ; preds = %for.cond2
  %9 = load i32, i32* %u, align 4
  %cmp5 = icmp ult i32 %9, 32
  br label %land.end6

land.end6:                                        ; preds = %land.rhs4, %for.cond2
  %10 = phi i1 [ false, %for.cond2 ], [ %cmp5, %land.rhs4 ]
  br i1 %10, label %for.body7, label %for.end

for.body7:                                        ; preds = %land.end6
  %11 = load i32, i32* %t, align 4
  %12 = load i32, i32* %u, align 4
  %shr = lshr i32 %11, %12
  %conv = trunc i32 %shr to i8
  %13 = load i32, i32* %j, align 4
  %14 = load i8*, i8** %hexarr.addr, align 4
  %arrayidx8 = getelementptr inbounds i8, i8* %14, i32 %13
  store i8 %conv, i8* %arrayidx8, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body7
  %15 = load i32, i32* %j, align 4
  %dec = add nsw i32 %15, -1
  store i32 %dec, i32* %j, align 4
  %16 = load i32, i32* %u, align 4
  %add = add i32 %16, 8
  store i32 %add, i32* %u, align 4
  br label %for.cond2

for.end:                                          ; preds = %land.end6
  br label %for.inc9

for.inc9:                                         ; preds = %for.end
  %17 = load i32, i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end10:                                        ; preds = %land.end
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc16, %for.end10
  %18 = load i32, i32* %j, align 4
  %cmp12 = icmp sge i32 %18, 0
  br i1 %cmp12, label %for.body14, label %for.end18

for.body14:                                       ; preds = %for.cond11
  %19 = load i32, i32* %j, align 4
  %20 = load i8*, i8** %hexarr.addr, align 4
  %arrayidx15 = getelementptr inbounds i8, i8* %20, i32 %19
  store i8 0, i8* %arrayidx15, align 1
  br label %for.inc16

for.inc16:                                        ; preds = %for.body14
  %21 = load i32, i32* %j, align 4
  %dec17 = add nsw i32 %21, -1
  store i32 %dec17, i32* %j, align 4
  br label %for.cond11

for.end18:                                        ; preds = %for.cond11
  ret void
}

; Function Attrs: noinline nounwind
define void @bn_assign(i32* %a, i32* %b, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %i = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %digits.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i, align 4
  %3 = load i32*, i32** %b.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %3, i32 %2
  %4 = load i32, i32* %arrayidx, align 4
  %5 = load i32, i32* %i, align 4
  %6 = load i32*, i32** %a.addr, align 4
  %arrayidx1 = getelementptr inbounds i32, i32* %6, i32 %5
  store i32 %4, i32* %arrayidx1, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind
define void @bn_assign_zero(i32* %a, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %a.addr = alloca i32*, align 4
  %i = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %digits.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i, align 4
  %3 = load i32*, i32** %a.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %3, i32 %2
  store i32 0, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load i32, i32* %i, align 4
  %inc = add i32 %4, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind
define void @bn_assign_2exp(i32* %a, i32 %b, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %a.addr = alloca i32*, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %digits.addr, align 4
  %1 = load i32*, i32** %a.addr, align 4
  call void @bn_assign_zero(i32* %1, i32 %0)
  %2 = load i32, i32* %b.addr, align 4
  %3 = load i32, i32* %digits.addr, align 4
  %mul = mul i32 %3, 32
  %cmp = icmp uge i32 %2, %mul
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, i32* %b.addr, align 4
  %rem = urem i32 %4, 32
  %shl = shl i32 1, %rem
  %5 = load i32, i32* %b.addr, align 4
  %div = udiv i32 %5, 32
  %6 = load i32*, i32** %a.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %6, i32 %div
  store i32 %shl, i32* %arrayidx, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: noinline nounwind
define i32 @bn_add(i32* %a, i32* %b, i32* %c, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %c.addr = alloca i32*, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %ai = alloca i32, align 4
  %carry = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %c, i32** %c.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  store i32 0, i32* %carry, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %digits.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i, align 4
  %3 = load i32*, i32** %b.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %3, i32 %2
  %4 = load i32, i32* %arrayidx, align 4
  %5 = load i32, i32* %carry, align 4
  %add = add i32 %4, %5
  store i32 %add, i32* %ai, align 4
  %6 = load i32, i32* %carry, align 4
  %cmp1 = icmp ult i32 %add, %6
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %7 = load i32, i32* %i, align 4
  %8 = load i32*, i32** %c.addr, align 4
  %arrayidx2 = getelementptr inbounds i32, i32* %8, i32 %7
  %9 = load i32, i32* %arrayidx2, align 4
  store i32 %9, i32* %ai, align 4
  br label %if.end9

if.else:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %11 = load i32*, i32** %c.addr, align 4
  %arrayidx3 = getelementptr inbounds i32, i32* %11, i32 %10
  %12 = load i32, i32* %arrayidx3, align 4
  %13 = load i32, i32* %ai, align 4
  %add4 = add i32 %13, %12
  store i32 %add4, i32* %ai, align 4
  %14 = load i32, i32* %i, align 4
  %15 = load i32*, i32** %c.addr, align 4
  %arrayidx5 = getelementptr inbounds i32, i32* %15, i32 %14
  %16 = load i32, i32* %arrayidx5, align 4
  %cmp6 = icmp ult i32 %add4, %16
  br i1 %cmp6, label %if.then7, label %if.else8

if.then7:                                         ; preds = %if.else
  store i32 1, i32* %carry, align 4
  br label %if.end

if.else8:                                         ; preds = %if.else
  store i32 0, i32* %carry, align 4
  br label %if.end

if.end:                                           ; preds = %if.else8, %if.then7
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then
  %17 = load i32, i32* %ai, align 4
  %18 = load i32, i32* %i, align 4
  %19 = load i32*, i32** %a.addr, align 4
  %arrayidx10 = getelementptr inbounds i32, i32* %19, i32 %18
  store i32 %17, i32* %arrayidx10, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %20 = load i32, i32* %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %21 = load i32, i32* %carry, align 4
  ret i32 %21
}

; Function Attrs: noinline nounwind
define i32 @bn_sub(i32* %a, i32* %b, i32* %c, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %c.addr = alloca i32*, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %ai = alloca i32, align 4
  %borrow = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %c, i32** %c.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  store i32 0, i32* %borrow, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %digits.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i, align 4
  %3 = load i32*, i32** %b.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %3, i32 %2
  %4 = load i32, i32* %arrayidx, align 4
  %5 = load i32, i32* %borrow, align 4
  %sub = sub i32 %4, %5
  store i32 %sub, i32* %ai, align 4
  %6 = load i32, i32* %borrow, align 4
  %sub1 = sub i32 -1, %6
  %cmp2 = icmp ugt i32 %sub, %sub1
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %7 = load i32, i32* %i, align 4
  %8 = load i32*, i32** %c.addr, align 4
  %arrayidx3 = getelementptr inbounds i32, i32* %8, i32 %7
  %9 = load i32, i32* %arrayidx3, align 4
  %sub4 = sub i32 -1, %9
  store i32 %sub4, i32* %ai, align 4
  br label %if.end12

if.else:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %11 = load i32*, i32** %c.addr, align 4
  %arrayidx5 = getelementptr inbounds i32, i32* %11, i32 %10
  %12 = load i32, i32* %arrayidx5, align 4
  %13 = load i32, i32* %ai, align 4
  %sub6 = sub i32 %13, %12
  store i32 %sub6, i32* %ai, align 4
  %14 = load i32, i32* %i, align 4
  %15 = load i32*, i32** %c.addr, align 4
  %arrayidx7 = getelementptr inbounds i32, i32* %15, i32 %14
  %16 = load i32, i32* %arrayidx7, align 4
  %sub8 = sub i32 -1, %16
  %cmp9 = icmp ugt i32 %sub6, %sub8
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else
  store i32 1, i32* %borrow, align 4
  br label %if.end

if.else11:                                        ; preds = %if.else
  store i32 0, i32* %borrow, align 4
  br label %if.end

if.end:                                           ; preds = %if.else11, %if.then10
  br label %if.end12

if.end12:                                         ; preds = %if.end, %if.then
  %17 = load i32, i32* %ai, align 4
  %18 = load i32, i32* %i, align 4
  %19 = load i32*, i32** %a.addr, align 4
  %arrayidx13 = getelementptr inbounds i32, i32* %19, i32 %18
  store i32 %17, i32* %arrayidx13, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %20 = load i32, i32* %i, align 4
  %inc = add i32 %20, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %21 = load i32, i32* %borrow, align 4
  ret i32 %21
}

; Function Attrs: noinline nounwind
define void @bn_mul(i32* %a, i32* %b, i32* %c, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %c.addr = alloca i32*, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %t = alloca [130 x i32], align 4
  %bdigits = alloca i32, align 4
  %cdigits = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %c, i32** %c.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %digits.addr, align 4
  %mul = mul i32 2, %0
  %arraydecay = getelementptr inbounds [130 x i32], [130 x i32]* %t, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay, i32 %mul)
  %1 = load i32, i32* %digits.addr, align 4
  %2 = load i32*, i32** %b.addr, align 4
  %call = call i32 @bn_digits(i32* %2, i32 %1)
  store i32 %call, i32* %bdigits, align 4
  %3 = load i32, i32* %digits.addr, align 4
  %4 = load i32*, i32** %c.addr, align 4
  %call1 = call i32 @bn_digits(i32* %4, i32 %3)
  store i32 %call1, i32* %cdigits, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %i, align 4
  %6 = load i32, i32* %bdigits, align 4
  %cmp = icmp ult i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32, i32* %cdigits, align 4
  %8 = load i32*, i32** %c.addr, align 4
  %9 = load i32, i32* %i, align 4
  %10 = load i32*, i32** %b.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %10, i32 %9
  %11 = load i32, i32* %arrayidx, align 4
  %12 = load i32, i32* %i, align 4
  %arrayidx2 = getelementptr inbounds [130 x i32], [130 x i32]* %t, i32 0, i32 %12
  %13 = load i32, i32* %i, align 4
  %arrayidx3 = getelementptr inbounds [130 x i32], [130 x i32]* %t, i32 0, i32 %13
  %call4 = call i32 @bn_add_digit_mul(i32* %arrayidx3, i32* %arrayidx2, i32 %11, i32* %8, i32 %7)
  %14 = load i32, i32* %i, align 4
  %15 = load i32, i32* %cdigits, align 4
  %add = add i32 %14, %15
  %arrayidx5 = getelementptr inbounds [130 x i32], [130 x i32]* %t, i32 0, i32 %add
  %16 = load i32, i32* %arrayidx5, align 4
  %add6 = add i32 %16, %call4
  store i32 %add6, i32* %arrayidx5, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32, i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* %digits.addr, align 4
  %mul7 = mul i32 2, %18
  %arraydecay8 = getelementptr inbounds [130 x i32], [130 x i32]* %t, i32 0, i32 0
  %19 = load i32*, i32** %a.addr, align 4
  call void @bn_assign(i32* %19, i32* %arraydecay8, i32 %mul7)
  %arraydecay9 = getelementptr inbounds [130 x i32], [130 x i32]* %t, i32 0, i32 0
  %20 = bitcast i32* %arraydecay9 to i8*
  call void @llvm.memset.p0i8.i32(i8* %20, i8 0, i32 520, i32 4, i1 false)
  ret void
}

; Function Attrs: noinline nounwind
define i32 @bn_digits(i32* %a, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %a.addr = alloca i32*, align 4
  %i = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %digits.addr, align 4
  %sub = sub i32 %0, 1
  store i32 %sub, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i, align 4
  %3 = load i32*, i32** %a.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %3, i32 %2
  %4 = load i32, i32* %arrayidx, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %5 = load i32, i32* %i, align 4
  %dec = add nsw i32 %5, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %6 = load i32, i32* %i, align 4
  %add = add nsw i32 %6, 1
  ret i32 %add
}

; Function Attrs: noinline nounwind
define internal i32 @bn_add_digit_mul(i32* %a, i32* %b, i32 %c, i32* %d, i32 %digits) #0 {
entry:
  %retval = alloca i32, align 4
  %digits.addr = alloca i32, align 4
  %d.addr = alloca i32*, align 4
  %c.addr = alloca i32, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %result = alloca i64, align 8
  %carry = alloca i32, align 4
  %rh = alloca i32, align 4
  %rl = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %d, i32** %d.addr, align 4
  store i32 %c, i32* %c.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %carry, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load i32, i32* %i, align 4
  %2 = load i32, i32* %digits.addr, align 4
  %cmp1 = icmp ult i32 %1, %2
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, i32* %c.addr, align 4
  %conv = zext i32 %3 to i64
  %4 = load i32, i32* %i, align 4
  %5 = load i32*, i32** %d.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %4
  %6 = load i32, i32* %arrayidx, align 4
  %conv2 = zext i32 %6 to i64
  %mul = mul i64 %conv, %conv2
  store i64 %mul, i64* %result, align 8
  %7 = load i64, i64* %result, align 8
  %and = and i64 %7, 4294967295
  %conv3 = trunc i64 %and to i32
  store i32 %conv3, i32* %rl, align 4
  %8 = load i64, i64* %result, align 8
  %shr = lshr i64 %8, 32
  %and4 = and i64 %shr, 4294967295
  %conv5 = trunc i64 %and4 to i32
  store i32 %conv5, i32* %rh, align 4
  %9 = load i32, i32* %i, align 4
  %10 = load i32*, i32** %b.addr, align 4
  %arrayidx6 = getelementptr inbounds i32, i32* %10, i32 %9
  %11 = load i32, i32* %arrayidx6, align 4
  %12 = load i32, i32* %carry, align 4
  %add = add i32 %11, %12
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %a.addr, align 4
  %arrayidx7 = getelementptr inbounds i32, i32* %14, i32 %13
  store i32 %add, i32* %arrayidx7, align 4
  %15 = load i32, i32* %carry, align 4
  %cmp8 = icmp ult i32 %add, %15
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %for.body
  store i32 1, i32* %carry, align 4
  br label %if.end11

if.else:                                          ; preds = %for.body
  store i32 0, i32* %carry, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then10
  %16 = load i32, i32* %rl, align 4
  %17 = load i32, i32* %i, align 4
  %18 = load i32*, i32** %a.addr, align 4
  %arrayidx12 = getelementptr inbounds i32, i32* %18, i32 %17
  %19 = load i32, i32* %arrayidx12, align 4
  %add13 = add i32 %19, %16
  store i32 %add13, i32* %arrayidx12, align 4
  %20 = load i32, i32* %rl, align 4
  %cmp14 = icmp ult i32 %add13, %20
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end11
  %21 = load i32, i32* %carry, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %carry, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end11
  %22 = load i32, i32* %rh, align 4
  %23 = load i32, i32* %carry, align 4
  %add18 = add i32 %23, %22
  store i32 %add18, i32* %carry, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %24 = load i32, i32* %i, align 4
  %inc19 = add i32 %24, 1
  store i32 %inc19, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %25 = load i32, i32* %carry, align 4
  store i32 %25, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i32(i8* nocapture, i8, i32, i32, i1) #1

; Function Attrs: noinline nounwind
define void @bn_div(i32* %a, i32* %b, i32* %c, i32 %cdigits, i32* %d, i32 %ddigits) #0 {
entry:
  %ddigits.addr = alloca i32, align 4
  %d.addr = alloca i32*, align 4
  %cdigits.addr = alloca i32, align 4
  %c.addr = alloca i32*, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %tmp = alloca i64, align 8
  %ai = alloca i32, align 4
  %t = alloca i32, align 4
  %cc = alloca [131 x i32], align 4
  %dd = alloca [65 x i32], align 4
  %i = alloca i32, align 4
  %dddigits = alloca i32, align 4
  %shift = alloca i32, align 4
  store i32 %ddigits, i32* %ddigits.addr, align 4
  store i32* %d, i32** %d.addr, align 4
  store i32 %cdigits, i32* %cdigits.addr, align 4
  store i32* %c, i32** %c.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %ddigits.addr, align 4
  %1 = load i32*, i32** %d.addr, align 4
  %call = call i32 @bn_digits(i32* %1, i32 %0)
  store i32 %call, i32* %dddigits, align 4
  %2 = load i32, i32* %dddigits, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %dddigits, align 4
  %sub = sub i32 %3, 1
  %4 = load i32*, i32** %d.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %4, i32 %sub
  %5 = load i32, i32* %arrayidx, align 4
  %call8 = call i32 @bn_digit_bits(i32 %5)
  %sub9 = sub i32 32, %call8
  store i32 %sub9, i32* %shift, align 4
  %6 = load i32, i32* %dddigits, align 4
  %arraydecay = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay, i32 %6)
  %7 = load i32, i32* %cdigits.addr, align 4
  %8 = load i32, i32* %shift, align 4
  %9 = load i32*, i32** %c.addr, align 4
  %arraydecay10 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 0
  %call11 = call i32 @bn_shift_l(i32* %arraydecay10, i32* %9, i32 %8, i32 %7)
  %10 = load i32, i32* %cdigits.addr, align 4
  %arrayidx12 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 %10
  store i32 %call11, i32* %arrayidx12, align 4
  %11 = load i32, i32* %dddigits, align 4
  %12 = load i32, i32* %shift, align 4
  %13 = load i32*, i32** %d.addr, align 4
  %arraydecay13 = getelementptr inbounds [65 x i32], [65 x i32]* %dd, i32 0, i32 0
  %call14 = call i32 @bn_shift_l(i32* %arraydecay13, i32* %13, i32 %12, i32 %11)
  %14 = load i32, i32* %dddigits, align 4
  %sub15 = sub i32 %14, 1
  %arrayidx16 = getelementptr inbounds [65 x i32], [65 x i32]* %dd, i32 0, i32 %sub15
  %15 = load i32, i32* %arrayidx16, align 4
  store i32 %15, i32* %t, align 4
  %16 = load i32, i32* %cdigits.addr, align 4
  %17 = load i32*, i32** %a.addr, align 4
  call void @bn_assign_zero(i32* %17, i32 %16)
  %18 = load i32, i32* %cdigits.addr, align 4
  %19 = load i32, i32* %dddigits, align 4
  %sub17 = sub i32 %18, %19
  store i32 %sub17, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %20 = load i32, i32* %i, align 4
  %cmp18 = icmp sge i32 %20, 0
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %21 = load i32, i32* %t, align 4
  %cmp19 = icmp eq i32 %21, -1
  br i1 %cmp19, label %if.then20, label %if.else

if.then20:                                        ; preds = %for.body
  %22 = load i32, i32* %i, align 4
  %23 = load i32, i32* %dddigits, align 4
  %add = add i32 %22, %23
  %arrayidx21 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 %add
  %24 = load i32, i32* %arrayidx21, align 4
  store i32 %24, i32* %ai, align 4
  br label %if.end32

if.else:                                          ; preds = %for.body
  %25 = load i32, i32* %i, align 4
  %26 = load i32, i32* %dddigits, align 4
  %add22 = add i32 %25, %26
  %sub23 = sub i32 %add22, 1
  %arrayidx24 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 %sub23
  %27 = load i32, i32* %arrayidx24, align 4
  %conv = zext i32 %27 to i64
  store i64 %conv, i64* %tmp, align 8
  %28 = load i32, i32* %i, align 4
  %29 = load i32, i32* %dddigits, align 4
  %add25 = add i32 %28, %29
  %arrayidx26 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 %add25
  %30 = load i32, i32* %arrayidx26, align 4
  %conv27 = zext i32 %30 to i64
  %shl = shl i64 %conv27, 32
  %31 = load i64, i64* %tmp, align 8
  %add28 = add i64 %31, %shl
  store i64 %add28, i64* %tmp, align 8
  %32 = load i64, i64* %tmp, align 8
  %33 = load i32, i32* %t, align 4
  %add29 = add i32 %33, 1
  %conv30 = zext i32 %add29 to i64
  %div = udiv i64 %32, %conv30
  %conv31 = trunc i64 %div to i32
  store i32 %conv31, i32* %ai, align 4
  br label %if.end32

if.end32:                                         ; preds = %if.else, %if.then20
  %34 = load i32, i32* %dddigits, align 4
  %arraydecay33 = getelementptr inbounds [65 x i32], [65 x i32]* %dd, i32 0, i32 0
  %35 = load i32, i32* %ai, align 4
  %36 = load i32, i32* %i, align 4
  %arrayidx34 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 %36
  %37 = load i32, i32* %i, align 4
  %arrayidx35 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 %37
  %call36 = call i32 @bn_sub_digit_mul(i32* %arrayidx35, i32* %arrayidx34, i32 %35, i32* %arraydecay33, i32 %34)
  %38 = load i32, i32* %i, align 4
  %39 = load i32, i32* %dddigits, align 4
  %add37 = add i32 %38, %39
  %arrayidx38 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 %add37
  %40 = load i32, i32* %arrayidx38, align 4
  %sub39 = sub i32 %40, %call36
  store i32 %sub39, i32* %arrayidx38, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end32
  %41 = load i32, i32* %i, align 4
  %42 = load i32, i32* %dddigits, align 4
  %add40 = add i32 %41, %42
  %arrayidx41 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 %add40
  %43 = load i32, i32* %arrayidx41, align 4
  %tobool = icmp ne i32 %43, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %44 = load i32, i32* %dddigits, align 4
  %arraydecay42 = getelementptr inbounds [65 x i32], [65 x i32]* %dd, i32 0, i32 0
  %45 = load i32, i32* %i, align 4
  %arrayidx43 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 %45
  %call44 = call i32 @bn_cmp(i32* %arrayidx43, i32* %arraydecay42, i32 %44)
  %cmp45 = icmp sge i32 %call44, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %while.cond
  %46 = phi i1 [ true, %while.cond ], [ %cmp45, %lor.rhs ]
  br i1 %46, label %while.body, label %while.end

while.body:                                       ; preds = %lor.end
  %47 = load i32, i32* %ai, align 4
  %inc = add i32 %47, 1
  store i32 %inc, i32* %ai, align 4
  %48 = load i32, i32* %dddigits, align 4
  %arraydecay47 = getelementptr inbounds [65 x i32], [65 x i32]* %dd, i32 0, i32 0
  %49 = load i32, i32* %i, align 4
  %arrayidx48 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 %49
  %50 = load i32, i32* %i, align 4
  %arrayidx49 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 %50
  %call50 = call i32 @bn_sub(i32* %arrayidx49, i32* %arrayidx48, i32* %arraydecay47, i32 %48)
  %51 = load i32, i32* %i, align 4
  %52 = load i32, i32* %dddigits, align 4
  %add51 = add i32 %51, %52
  %arrayidx52 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 %add51
  %53 = load i32, i32* %arrayidx52, align 4
  %sub53 = sub i32 %53, %call50
  store i32 %sub53, i32* %arrayidx52, align 4
  br label %while.cond

while.end:                                        ; preds = %lor.end
  %54 = load i32, i32* %ai, align 4
  %55 = load i32, i32* %i, align 4
  %56 = load i32*, i32** %a.addr, align 4
  %arrayidx54 = getelementptr inbounds i32, i32* %56, i32 %55
  store i32 %54, i32* %arrayidx54, align 4
  br label %for.inc

for.inc:                                          ; preds = %while.end
  %57 = load i32, i32* %i, align 4
  %dec = add nsw i32 %57, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %58 = load i32, i32* %ddigits.addr, align 4
  %59 = load i32*, i32** %b.addr, align 4
  call void @bn_assign_zero(i32* %59, i32 %58)
  %60 = load i32, i32* %dddigits, align 4
  %61 = load i32, i32* %shift, align 4
  %arraydecay55 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 0
  %62 = load i32*, i32** %b.addr, align 4
  %call56 = call i32 @bn_shift_r(i32* %62, i32* %arraydecay55, i32 %61, i32 %60)
  %arraydecay57 = getelementptr inbounds [131 x i32], [131 x i32]* %cc, i32 0, i32 0
  %63 = bitcast i32* %arraydecay57 to i8*
  call void @llvm.memset.p0i8.i32(i8* %63, i8 0, i32 524, i32 4, i1 false)
  %arraydecay58 = getelementptr inbounds [65 x i32], [65 x i32]* %dd, i32 0, i32 0
  %64 = bitcast i32* %arraydecay58 to i8*
  call void @llvm.memset.p0i8.i32(i8* %64, i8 0, i32 260, i32 4, i1 false)
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

; Function Attrs: noinline nounwind
define internal i32 @bn_digit_bits(i32 %a) #0 {
entry:
  %a.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp ult i32 %0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load i32, i32* %a.addr, align 4
  %cmp1 = icmp eq i32 %1, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  %2 = load i32, i32* %a.addr, align 4
  %shr = lshr i32 %2, 1
  store i32 %shr, i32* %a.addr, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %3 = load i32, i32* %i, align 4
  %inc = add i32 %3, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %4 = load i32, i32* %i, align 4
  ret i32 %4
}

; Function Attrs: noinline nounwind
define i32 @bn_shift_l(i32* %a, i32* %b, i32 %c, i32 %digits) #0 {
entry:
  %retval = alloca i32, align 4
  %digits.addr = alloca i32, align 4
  %c.addr = alloca i32, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %bi = alloca i32, align 4
  %carry = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32 %c, i32* %c.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %cmp = icmp uge i32 %0, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %c.addr, align 4
  %sub = sub i32 32, %1
  store i32 %sub, i32* %t, align 4
  store i32 0, i32* %carry, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %digits.addr, align 4
  %cmp1 = icmp ult i32 %2, %3
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, i32* %i, align 4
  %5 = load i32*, i32** %b.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %4
  %6 = load i32, i32* %arrayidx, align 4
  store i32 %6, i32* %bi, align 4
  %7 = load i32, i32* %bi, align 4
  %8 = load i32, i32* %c.addr, align 4
  %shl = shl i32 %7, %8
  %9 = load i32, i32* %carry, align 4
  %or = or i32 %shl, %9
  %10 = load i32, i32* %i, align 4
  %11 = load i32*, i32** %a.addr, align 4
  %arrayidx2 = getelementptr inbounds i32, i32* %11, i32 %10
  store i32 %or, i32* %arrayidx2, align 4
  %12 = load i32, i32* %c.addr, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %13 = load i32, i32* %bi, align 4
  %14 = load i32, i32* %t, align 4
  %shr = lshr i32 %13, %14
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %shr, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %carry, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %15 = load i32, i32* %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %16 = load i32, i32* %carry, align 4
  store i32 %16, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %17 = load i32, i32* %retval, align 4
  ret i32 %17
}

; Function Attrs: noinline nounwind
define internal i32 @bn_sub_digit_mul(i32* %a, i32* %b, i32 %c, i32* %d, i32 %digits) #0 {
entry:
  %retval = alloca i32, align 4
  %digits.addr = alloca i32, align 4
  %d.addr = alloca i32*, align 4
  %c.addr = alloca i32, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %result = alloca i64, align 8
  %borrow = alloca i32, align 4
  %rh = alloca i32, align 4
  %rl = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %d, i32** %d.addr, align 4
  store i32 %c, i32* %c.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %borrow, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load i32, i32* %i, align 4
  %2 = load i32, i32* %digits.addr, align 4
  %cmp1 = icmp ult i32 %1, %2
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, i32* %c.addr, align 4
  %conv = zext i32 %3 to i64
  %4 = load i32, i32* %i, align 4
  %5 = load i32*, i32** %d.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %4
  %6 = load i32, i32* %arrayidx, align 4
  %conv2 = zext i32 %6 to i64
  %mul = mul i64 %conv, %conv2
  store i64 %mul, i64* %result, align 8
  %7 = load i64, i64* %result, align 8
  %and = and i64 %7, 4294967295
  %conv3 = trunc i64 %and to i32
  store i32 %conv3, i32* %rl, align 4
  %8 = load i64, i64* %result, align 8
  %shr = lshr i64 %8, 32
  %and4 = and i64 %shr, 4294967295
  %conv5 = trunc i64 %and4 to i32
  store i32 %conv5, i32* %rh, align 4
  %9 = load i32, i32* %i, align 4
  %10 = load i32*, i32** %b.addr, align 4
  %arrayidx6 = getelementptr inbounds i32, i32* %10, i32 %9
  %11 = load i32, i32* %arrayidx6, align 4
  %12 = load i32, i32* %borrow, align 4
  %sub = sub i32 %11, %12
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %a.addr, align 4
  %arrayidx7 = getelementptr inbounds i32, i32* %14, i32 %13
  store i32 %sub, i32* %arrayidx7, align 4
  %15 = load i32, i32* %borrow, align 4
  %sub8 = sub i32 -1, %15
  %cmp9 = icmp ugt i32 %sub, %sub8
  br i1 %cmp9, label %if.then11, label %if.else

if.then11:                                        ; preds = %for.body
  store i32 1, i32* %borrow, align 4
  br label %if.end12

if.else:                                          ; preds = %for.body
  store i32 0, i32* %borrow, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.else, %if.then11
  %16 = load i32, i32* %rl, align 4
  %17 = load i32, i32* %i, align 4
  %18 = load i32*, i32** %a.addr, align 4
  %arrayidx13 = getelementptr inbounds i32, i32* %18, i32 %17
  %19 = load i32, i32* %arrayidx13, align 4
  %sub14 = sub i32 %19, %16
  store i32 %sub14, i32* %arrayidx13, align 4
  %20 = load i32, i32* %rl, align 4
  %sub15 = sub i32 -1, %20
  %cmp16 = icmp ugt i32 %sub14, %sub15
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end12
  %21 = load i32, i32* %borrow, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %borrow, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end12
  %22 = load i32, i32* %rh, align 4
  %23 = load i32, i32* %borrow, align 4
  %add = add i32 %23, %22
  store i32 %add, i32* %borrow, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %24 = load i32, i32* %i, align 4
  %inc20 = add i32 %24, 1
  store i32 %inc20, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %25 = load i32, i32* %borrow, align 4
  store i32 %25, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %26 = load i32, i32* %retval, align 4
  ret i32 %26
}

; Function Attrs: noinline nounwind
define i32 @bn_cmp(i32* %a, i32* %b, i32 %digits) #0 {
entry:
  %retval = alloca i32, align 4
  %digits.addr = alloca i32, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %i = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %digits.addr, align 4
  %sub = sub i32 %0, 1
  store i32 %sub, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i, align 4
  %3 = load i32*, i32** %a.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %3, i32 %2
  %4 = load i32, i32* %arrayidx, align 4
  %5 = load i32, i32* %i, align 4
  %6 = load i32*, i32** %b.addr, align 4
  %arrayidx1 = getelementptr inbounds i32, i32* %6, i32 %5
  %7 = load i32, i32* %arrayidx1, align 4
  %cmp2 = icmp ugt i32 %4, %7
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i32 1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %9 = load i32*, i32** %a.addr, align 4
  %arrayidx3 = getelementptr inbounds i32, i32* %9, i32 %8
  %10 = load i32, i32* %arrayidx3, align 4
  %11 = load i32, i32* %i, align 4
  %12 = load i32*, i32** %b.addr, align 4
  %arrayidx4 = getelementptr inbounds i32, i32* %12, i32 %11
  %13 = load i32, i32* %arrayidx4, align 4
  %cmp5 = icmp ult i32 %10, %13
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i32 -1, i32* %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %14 = load i32, i32* %i, align 4
  %dec = add nsw i32 %14, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then6, %if.then
  %15 = load i32, i32* %retval, align 4
  ret i32 %15
}

; Function Attrs: noinline nounwind
define i32 @bn_shift_r(i32* %a, i32* %b, i32 %c, i32 %digits) #0 {
entry:
  %retval = alloca i32, align 4
  %digits.addr = alloca i32, align 4
  %c.addr = alloca i32, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %bi = alloca i32, align 4
  %carry = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32 %c, i32* %c.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %cmp = icmp uge i32 %0, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %c.addr, align 4
  %sub = sub i32 32, %1
  store i32 %sub, i32* %t, align 4
  store i32 0, i32* %carry, align 4
  %2 = load i32, i32* %digits.addr, align 4
  %sub1 = sub i32 %2, 1
  store i32 %sub1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %i, align 4
  %cmp2 = icmp sge i32 %3, 0
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, i32* %i, align 4
  %5 = load i32*, i32** %b.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %5, i32 %4
  %6 = load i32, i32* %arrayidx, align 4
  store i32 %6, i32* %bi, align 4
  %7 = load i32, i32* %bi, align 4
  %8 = load i32, i32* %c.addr, align 4
  %shr = lshr i32 %7, %8
  %9 = load i32, i32* %carry, align 4
  %or = or i32 %shr, %9
  %10 = load i32, i32* %i, align 4
  %11 = load i32*, i32** %a.addr, align 4
  %arrayidx3 = getelementptr inbounds i32, i32* %11, i32 %10
  store i32 %or, i32* %arrayidx3, align 4
  %12 = load i32, i32* %c.addr, align 4
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %13 = load i32, i32* %bi, align 4
  %14 = load i32, i32* %t, align 4
  %shl = shl i32 %13, %14
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %shl, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %carry, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %15 = load i32, i32* %i, align 4
  %dec = add nsw i32 %15, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %16 = load i32, i32* %carry, align 4
  store i32 %16, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %17 = load i32, i32* %retval, align 4
  ret i32 %17
}

; Function Attrs: noinline nounwind
define void @bn_mod(i32* %a, i32* %b, i32 %bdigits, i32* %c, i32 %cdigits) #0 {
entry:
  %cdigits.addr = alloca i32, align 4
  %c.addr = alloca i32*, align 4
  %bdigits.addr = alloca i32, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %t = alloca [130 x i32], align 4
  store i32 %cdigits, i32* %cdigits.addr, align 4
  store i32* %c, i32** %c.addr, align 4
  store i32 %bdigits, i32* %bdigits.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = bitcast [130 x i32]* %t to i8*
  call void @llvm.memset.p0i8.i32(i8* %0, i8 0, i32 520, i32 4, i1 false)
  %1 = load i32, i32* %cdigits.addr, align 4
  %2 = load i32*, i32** %c.addr, align 4
  %3 = load i32, i32* %bdigits.addr, align 4
  %4 = load i32*, i32** %b.addr, align 4
  %5 = load i32*, i32** %a.addr, align 4
  %arraydecay = getelementptr inbounds [130 x i32], [130 x i32]* %t, i32 0, i32 0
  call void @bn_div(i32* %arraydecay, i32* %5, i32* %4, i32 %3, i32* %2, i32 %1)
  %arraydecay1 = getelementptr inbounds [130 x i32], [130 x i32]* %t, i32 0, i32 0
  %6 = bitcast i32* %arraydecay1 to i8*
  call void @llvm.memset.p0i8.i32(i8* %6, i8 0, i32 520, i32 4, i1 false)
  ret void
}

; Function Attrs: noinline nounwind
define void @bn_mod_mul(i32* %a, i32* %b, i32* %c, i32* %d, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %d.addr = alloca i32*, align 4
  %c.addr = alloca i32*, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %t = alloca [130 x i32], align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %d, i32** %d.addr, align 4
  store i32* %c, i32** %c.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %digits.addr, align 4
  %1 = load i32*, i32** %c.addr, align 4
  %2 = load i32*, i32** %b.addr, align 4
  %arraydecay = getelementptr inbounds [130 x i32], [130 x i32]* %t, i32 0, i32 0
  call void @bn_mul(i32* %arraydecay, i32* %2, i32* %1, i32 %0)
  %3 = load i32, i32* %digits.addr, align 4
  %4 = load i32*, i32** %d.addr, align 4
  %5 = load i32, i32* %digits.addr, align 4
  %mul = mul i32 2, %5
  %arraydecay1 = getelementptr inbounds [130 x i32], [130 x i32]* %t, i32 0, i32 0
  %6 = load i32*, i32** %a.addr, align 4
  call void @bn_mod(i32* %6, i32* %arraydecay1, i32 %mul, i32* %4, i32 %3)
  %arraydecay2 = getelementptr inbounds [130 x i32], [130 x i32]* %t, i32 0, i32 0
  %7 = bitcast i32* %arraydecay2 to i8*
  call void @llvm.memset.p0i8.i32(i8* %7, i8 0, i32 520, i32 4, i1 false)
  ret void
}

; Function Attrs: noinline nounwind
define void @bn_mod_exp(i32* %a, i32* %b, i32* %c, i32 %cdigits, i32* %d, i32 %ddigits) #0 {
entry:
  %ddigits.addr = alloca i32, align 4
  %d.addr = alloca i32*, align 4
  %cdigits.addr = alloca i32, align 4
  %c.addr = alloca i32*, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %bpower = alloca [3 x [65 x i32]], align 4
  %ci = alloca i32, align 4
  %t = alloca [65 x i32], align 4
  %i = alloca i32, align 4
  %ci_bits = alloca i32, align 4
  %j = alloca i32, align 4
  %s = alloca i32, align 4
  store i32 %ddigits, i32* %ddigits.addr, align 4
  store i32* %d, i32** %d.addr, align 4
  store i32 %cdigits, i32* %cdigits.addr, align 4
  store i32* %c, i32** %c.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %ddigits.addr, align 4
  %1 = load i32*, i32** %b.addr, align 4
  %arrayidx = getelementptr inbounds [3 x [65 x i32]], [3 x [65 x i32]]* %bpower, i32 0, i32 0
  %arraydecay = getelementptr inbounds [65 x i32], [65 x i32]* %arrayidx, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay, i32* %1, i32 %0)
  %2 = load i32, i32* %ddigits.addr, align 4
  %3 = load i32*, i32** %d.addr, align 4
  %4 = load i32*, i32** %b.addr, align 4
  %arrayidx1 = getelementptr inbounds [3 x [65 x i32]], [3 x [65 x i32]]* %bpower, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [65 x i32], [65 x i32]* %arrayidx1, i32 0, i32 0
  %arrayidx3 = getelementptr inbounds [3 x [65 x i32]], [3 x [65 x i32]]* %bpower, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [65 x i32], [65 x i32]* %arrayidx3, i32 0, i32 0
  call void @bn_mod_mul(i32* %arraydecay4, i32* %arraydecay2, i32* %4, i32* %3, i32 %2)
  %5 = load i32, i32* %ddigits.addr, align 4
  %6 = load i32*, i32** %d.addr, align 4
  %7 = load i32*, i32** %b.addr, align 4
  %arrayidx5 = getelementptr inbounds [3 x [65 x i32]], [3 x [65 x i32]]* %bpower, i32 0, i32 1
  %arraydecay6 = getelementptr inbounds [65 x i32], [65 x i32]* %arrayidx5, i32 0, i32 0
  %arrayidx7 = getelementptr inbounds [3 x [65 x i32]], [3 x [65 x i32]]* %bpower, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [65 x i32], [65 x i32]* %arrayidx7, i32 0, i32 0
  call void @bn_mod_mul(i32* %arraydecay8, i32* %arraydecay6, i32* %7, i32* %6, i32 %5)
  %8 = load i32, i32* %ddigits.addr, align 4
  %arraydecay9 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay9, i32 %8)
  %arrayidx10 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  store i32 1, i32* %arrayidx10, align 4
  %9 = load i32, i32* %cdigits.addr, align 4
  %10 = load i32*, i32** %c.addr, align 4
  %call = call i32 @bn_digits(i32* %10, i32 %9)
  store i32 %call, i32* %cdigits.addr, align 4
  %11 = load i32, i32* %cdigits.addr, align 4
  %sub = sub i32 %11, 1
  store i32 %sub, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc35, %entry
  %12 = load i32, i32* %i, align 4
  %cmp = icmp sge i32 %12, 0
  br i1 %cmp, label %for.body, label %for.end36

for.body:                                         ; preds = %for.cond
  %13 = load i32, i32* %i, align 4
  %14 = load i32*, i32** %c.addr, align 4
  %arrayidx11 = getelementptr inbounds i32, i32* %14, i32 %13
  %15 = load i32, i32* %arrayidx11, align 4
  store i32 %15, i32* %ci, align 4
  store i32 32, i32* %ci_bits, align 4
  %16 = load i32, i32* %i, align 4
  %17 = load i32, i32* %cdigits.addr, align 4
  %sub12 = sub i32 %17, 1
  %cmp13 = icmp eq i32 %16, %sub12
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %18 = load i32, i32* %ci, align 4
  %shr = lshr i32 %18, 30
  %and = and i32 %shr, 3
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %19 = load i32, i32* %ci, align 4
  %shl = shl i32 %19, 2
  store i32 %shl, i32* %ci, align 4
  %20 = load i32, i32* %ci_bits, align 4
  %sub14 = sub i32 %20, 2
  store i32 %sub14, i32* %ci_bits, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %if.end

if.end:                                           ; preds = %while.end, %for.body
  store i32 0, i32* %j, align 4
  br label %for.cond15

for.cond15:                                       ; preds = %for.inc, %if.end
  %21 = load i32, i32* %j, align 4
  %22 = load i32, i32* %ci_bits, align 4
  %cmp16 = icmp ult i32 %21, %22
  br i1 %cmp16, label %for.body17, label %for.end

for.body17:                                       ; preds = %for.cond15
  %23 = load i32, i32* %ddigits.addr, align 4
  %24 = load i32*, i32** %d.addr, align 4
  %arraydecay18 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay19 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay20 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_mod_mul(i32* %arraydecay20, i32* %arraydecay19, i32* %arraydecay18, i32* %24, i32 %23)
  %25 = load i32, i32* %ddigits.addr, align 4
  %26 = load i32*, i32** %d.addr, align 4
  %arraydecay21 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay22 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay23 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_mod_mul(i32* %arraydecay23, i32* %arraydecay22, i32* %arraydecay21, i32* %26, i32 %25)
  %27 = load i32, i32* %ci, align 4
  %shr24 = lshr i32 %27, 30
  %and25 = and i32 %shr24, 3
  store i32 %and25, i32* %s, align 4
  %cmp26 = icmp ne i32 %and25, 0
  br i1 %cmp26, label %if.then27, label %if.end33

if.then27:                                        ; preds = %for.body17
  %28 = load i32, i32* %ddigits.addr, align 4
  %29 = load i32*, i32** %d.addr, align 4
  %30 = load i32, i32* %s, align 4
  %sub28 = sub i32 %30, 1
  %arrayidx29 = getelementptr inbounds [3 x [65 x i32]], [3 x [65 x i32]]* %bpower, i32 0, i32 %sub28
  %arraydecay30 = getelementptr inbounds [65 x i32], [65 x i32]* %arrayidx29, i32 0, i32 0
  %arraydecay31 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay32 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_mod_mul(i32* %arraydecay32, i32* %arraydecay31, i32* %arraydecay30, i32* %29, i32 %28)
  br label %if.end33

if.end33:                                         ; preds = %if.then27, %for.body17
  %31 = load i32, i32* %ci, align 4
  %shl34 = shl i32 %31, 2
  store i32 %shl34, i32* %ci, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end33
  %32 = load i32, i32* %j, align 4
  %add = add i32 %32, 2
  store i32 %add, i32* %j, align 4
  br label %for.cond15

for.end:                                          ; preds = %for.cond15
  br label %for.inc35

for.inc35:                                        ; preds = %for.end
  %33 = load i32, i32* %i, align 4
  %dec = add nsw i32 %33, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end36:                                        ; preds = %for.cond
  %34 = load i32, i32* %ddigits.addr, align 4
  %arraydecay37 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %35 = load i32*, i32** %a.addr, align 4
  call void @bn_assign(i32* %35, i32* %arraydecay37, i32 %34)
  %arraydecay38 = getelementptr inbounds [3 x [65 x i32]], [3 x [65 x i32]]* %bpower, i32 0, i32 0
  %36 = bitcast [65 x i32]* %arraydecay38 to i8*
  call void @llvm.memset.p0i8.i32(i8* %36, i8 0, i32 780, i32 4, i1 false)
  %arraydecay39 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %37 = bitcast i32* %arraydecay39 to i8*
  call void @llvm.memset.p0i8.i32(i8* %37, i8 0, i32 260, i32 4, i1 false)
  ret void
}

; Function Attrs: noinline nounwind
define void @bn_mod_inv(i32* %a, i32* %b, i32* %c, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %c.addr = alloca i32*, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %q = alloca [65 x i32], align 4
  %t1 = alloca [65 x i32], align 4
  %t3 = alloca [65 x i32], align 4
  %w = alloca [130 x i32], align 4
  %u1 = alloca [65 x i32], align 4
  %u3 = alloca [65 x i32], align 4
  %v1 = alloca [65 x i32], align 4
  %v3 = alloca [65 x i32], align 4
  %u1_sign = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %c, i32** %c.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %digits.addr, align 4
  %arraydecay = getelementptr inbounds [65 x i32], [65 x i32]* %u1, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay, i32 %0)
  %arrayidx = getelementptr inbounds [65 x i32], [65 x i32]* %u1, i32 0, i32 0
  store i32 1, i32* %arrayidx, align 4
  %1 = load i32, i32* %digits.addr, align 4
  %arraydecay1 = getelementptr inbounds [65 x i32], [65 x i32]* %v1, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay1, i32 %1)
  %2 = load i32, i32* %digits.addr, align 4
  %3 = load i32*, i32** %b.addr, align 4
  %arraydecay2 = getelementptr inbounds [65 x i32], [65 x i32]* %u3, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay2, i32* %3, i32 %2)
  %4 = load i32, i32* %digits.addr, align 4
  %5 = load i32*, i32** %c.addr, align 4
  %arraydecay3 = getelementptr inbounds [65 x i32], [65 x i32]* %v3, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay3, i32* %5, i32 %4)
  store i32 1, i32* %u1_sign, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %6 = load i32, i32* %digits.addr, align 4
  %arraydecay4 = getelementptr inbounds [65 x i32], [65 x i32]* %v3, i32 0, i32 0
  %call = call i32 @bn_is_zero(i32* %arraydecay4, i32 %6)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %7 = load i32, i32* %digits.addr, align 4
  %arraydecay5 = getelementptr inbounds [65 x i32], [65 x i32]* %v3, i32 0, i32 0
  %8 = load i32, i32* %digits.addr, align 4
  %arraydecay6 = getelementptr inbounds [65 x i32], [65 x i32]* %u3, i32 0, i32 0
  %arraydecay7 = getelementptr inbounds [65 x i32], [65 x i32]* %t3, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  call void @bn_div(i32* %arraydecay8, i32* %arraydecay7, i32* %arraydecay6, i32 %8, i32* %arraydecay5, i32 %7)
  %9 = load i32, i32* %digits.addr, align 4
  %arraydecay9 = getelementptr inbounds [65 x i32], [65 x i32]* %v1, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %arraydecay11 = getelementptr inbounds [130 x i32], [130 x i32]* %w, i32 0, i32 0
  call void @bn_mul(i32* %arraydecay11, i32* %arraydecay10, i32* %arraydecay9, i32 %9)
  %10 = load i32, i32* %digits.addr, align 4
  %arraydecay12 = getelementptr inbounds [130 x i32], [130 x i32]* %w, i32 0, i32 0
  %arraydecay13 = getelementptr inbounds [65 x i32], [65 x i32]* %u1, i32 0, i32 0
  %arraydecay14 = getelementptr inbounds [65 x i32], [65 x i32]* %t1, i32 0, i32 0
  %call15 = call i32 @bn_add(i32* %arraydecay14, i32* %arraydecay13, i32* %arraydecay12, i32 %10)
  %11 = load i32, i32* %digits.addr, align 4
  %arraydecay16 = getelementptr inbounds [65 x i32], [65 x i32]* %v1, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [65 x i32], [65 x i32]* %u1, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay17, i32* %arraydecay16, i32 %11)
  %12 = load i32, i32* %digits.addr, align 4
  %arraydecay18 = getelementptr inbounds [65 x i32], [65 x i32]* %t1, i32 0, i32 0
  %arraydecay19 = getelementptr inbounds [65 x i32], [65 x i32]* %v1, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay19, i32* %arraydecay18, i32 %12)
  %13 = load i32, i32* %digits.addr, align 4
  %arraydecay20 = getelementptr inbounds [65 x i32], [65 x i32]* %v3, i32 0, i32 0
  %arraydecay21 = getelementptr inbounds [65 x i32], [65 x i32]* %u3, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay21, i32* %arraydecay20, i32 %13)
  %14 = load i32, i32* %digits.addr, align 4
  %arraydecay22 = getelementptr inbounds [65 x i32], [65 x i32]* %t3, i32 0, i32 0
  %arraydecay23 = getelementptr inbounds [65 x i32], [65 x i32]* %v3, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay23, i32* %arraydecay22, i32 %14)
  %15 = load i32, i32* %u1_sign, align 4
  %sub = sub nsw i32 0, %15
  store i32 %sub, i32* %u1_sign, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load i32, i32* %u1_sign, align 4
  %cmp = icmp slt i32 %16, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %while.end
  %17 = load i32, i32* %digits.addr, align 4
  %arraydecay24 = getelementptr inbounds [65 x i32], [65 x i32]* %u1, i32 0, i32 0
  %18 = load i32*, i32** %c.addr, align 4
  %19 = load i32*, i32** %a.addr, align 4
  %call25 = call i32 @bn_sub(i32* %19, i32* %18, i32* %arraydecay24, i32 %17)
  br label %if.end

if.else:                                          ; preds = %while.end
  %20 = load i32, i32* %digits.addr, align 4
  %arraydecay26 = getelementptr inbounds [65 x i32], [65 x i32]* %u1, i32 0, i32 0
  %21 = load i32*, i32** %a.addr, align 4
  call void @bn_assign(i32* %21, i32* %arraydecay26, i32 %20)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %arraydecay27 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %22 = bitcast i32* %arraydecay27 to i8*
  call void @llvm.memset.p0i8.i32(i8* %22, i8 0, i32 260, i32 4, i1 false)
  %arraydecay28 = getelementptr inbounds [65 x i32], [65 x i32]* %t1, i32 0, i32 0
  %23 = bitcast i32* %arraydecay28 to i8*
  call void @llvm.memset.p0i8.i32(i8* %23, i8 0, i32 260, i32 4, i1 false)
  %arraydecay29 = getelementptr inbounds [65 x i32], [65 x i32]* %t3, i32 0, i32 0
  %24 = bitcast i32* %arraydecay29 to i8*
  call void @llvm.memset.p0i8.i32(i8* %24, i8 0, i32 260, i32 4, i1 false)
  %arraydecay30 = getelementptr inbounds [65 x i32], [65 x i32]* %u1, i32 0, i32 0
  %25 = bitcast i32* %arraydecay30 to i8*
  call void @llvm.memset.p0i8.i32(i8* %25, i8 0, i32 260, i32 4, i1 false)
  %arraydecay31 = getelementptr inbounds [65 x i32], [65 x i32]* %u3, i32 0, i32 0
  %26 = bitcast i32* %arraydecay31 to i8*
  call void @llvm.memset.p0i8.i32(i8* %26, i8 0, i32 260, i32 4, i1 false)
  %arraydecay32 = getelementptr inbounds [65 x i32], [65 x i32]* %v1, i32 0, i32 0
  %27 = bitcast i32* %arraydecay32 to i8*
  call void @llvm.memset.p0i8.i32(i8* %27, i8 0, i32 260, i32 4, i1 false)
  %arraydecay33 = getelementptr inbounds [65 x i32], [65 x i32]* %v3, i32 0, i32 0
  %28 = bitcast i32* %arraydecay33 to i8*
  call void @llvm.memset.p0i8.i32(i8* %28, i8 0, i32 260, i32 4, i1 false)
  %arraydecay34 = getelementptr inbounds [130 x i32], [130 x i32]* %w, i32 0, i32 0
  %29 = bitcast i32* %arraydecay34 to i8*
  call void @llvm.memset.p0i8.i32(i8* %29, i8 0, i32 520, i32 4, i1 false)
  ret void
}

; Function Attrs: noinline nounwind
define i32 @bn_is_zero(i32* %a, i32 %digits) #0 {
entry:
  %retval = alloca i32, align 4
  %digits.addr = alloca i32, align 4
  %a.addr = alloca i32*, align 4
  %i = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %digits.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i, align 4
  %3 = load i32*, i32** %a.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %3, i32 %2
  %4 = load i32, i32* %arrayidx, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %5 = load i32, i32* %i, align 4
  %inc = add i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 1, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind
define void @bn_gcd(i32* %a, i32* %b, i32* %c, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %c.addr = alloca i32*, align 4
  %b.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %t = alloca [65 x i32], align 4
  %u = alloca [65 x i32], align 4
  %v = alloca [65 x i32], align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %c, i32** %c.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %digits.addr, align 4
  %1 = load i32*, i32** %b.addr, align 4
  %arraydecay = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay, i32* %1, i32 %0)
  %2 = load i32, i32* %digits.addr, align 4
  %3 = load i32*, i32** %c.addr, align 4
  %arraydecay1 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay1, i32* %3, i32 %2)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %4 = load i32, i32* %digits.addr, align 4
  %arraydecay2 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  %call = call i32 @bn_is_zero(i32* %arraydecay2, i32 %4)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load i32, i32* %digits.addr, align 4
  %arraydecay3 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  %6 = load i32, i32* %digits.addr, align 4
  %arraydecay4 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_mod(i32* %arraydecay5, i32* %arraydecay4, i32 %6, i32* %arraydecay3, i32 %5)
  %7 = load i32, i32* %digits.addr, align 4
  %arraydecay6 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  %arraydecay7 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay7, i32* %arraydecay6, i32 %7)
  %8 = load i32, i32* %digits.addr, align 4
  %arraydecay8 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay9 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay9, i32* %arraydecay8, i32 %8)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %9 = load i32, i32* %digits.addr, align 4
  %arraydecay10 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %10 = load i32*, i32** %a.addr, align 4
  call void @bn_assign(i32* %10, i32* %arraydecay10, i32 %9)
  %arraydecay11 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %11 = bitcast i32* %arraydecay11 to i8*
  call void @llvm.memset.p0i8.i32(i8* %11, i8 0, i32 260, i32 4, i1 false)
  %arraydecay12 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %12 = bitcast i32* %arraydecay12 to i8*
  call void @llvm.memset.p0i8.i32(i8* %12, i8 0, i32 260, i32 4, i1 false)
  %arraydecay13 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  %13 = bitcast i32* %arraydecay13 to i8*
  call void @llvm.memset.p0i8.i32(i8* %13, i8 0, i32 260, i32 4, i1 false)
  ret void
}

; Function Attrs: noinline nounwind
define i32 @bn_bits(i32* %a, i32 %digits) #0 {
entry:
  %retval = alloca i32, align 4
  %digits.addr = alloca i32, align 4
  %a.addr = alloca i32*, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %digits.addr, align 4
  %1 = load i32*, i32** %a.addr, align 4
  %call = call i32 @bn_digits(i32* %1, i32 %0)
  store i32 %call, i32* %digits.addr, align 4
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %digits.addr, align 4
  %sub = sub i32 %2, 1
  %mul = mul i32 %sub, 32
  %3 = load i32, i32* %digits.addr, align 4
  %sub1 = sub i32 %3, 1
  %4 = load i32*, i32** %a.addr, align 4
  %arrayidx = getelementptr inbounds i32, i32* %4, i32 %sub1
  %5 = load i32, i32* %arrayidx, align 4
  %call2 = call i32 @bn_digit_bits(i32 %5)
  %add = add i32 %mul, %call2
  store i32 %add, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: noinline nounwind
define void @print_bn(i8* %TAG, i32* %bn, i32 %bn_size) #0 {
entry:
  %bn_size.addr = alloca i32, align 4
  %bn.addr = alloca i32*, align 4
  %TAG.addr = alloca i8*, align 4
  %buf = alloca [512 x i8], align 1
  %i = alloca i32, align 4
  store i32 %bn_size, i32* %bn_size.addr, align 4
  store i32* %bn, i32** %bn.addr, align 4
  store i8* %TAG, i8** %TAG.addr, align 4
  %arraydecay = getelementptr inbounds [512 x i8], [512 x i8]* %buf, i32 0, i32 0
  call void @llvm.memset.p0i8.i32(i8* %arraydecay, i8 0, i32 512, i32 1, i1 false)
  %0 = load i32, i32* %bn_size.addr, align 4
  %1 = load i32*, i32** %bn.addr, align 4
  %arraydecay1 = getelementptr inbounds [512 x i8], [512 x i8]* %buf, i32 0, i32 0
  call void @bn_encode(i8* %arraydecay1, i32 512, i32* %1, i32 %0)
  %2 = load i32, i32* %bn_size.addr, align 4
  %3 = load i8*, i8** %TAG.addr, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str, i32 0, i32 0), i8* %3, i32 %2)
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %4 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds [512 x i8], [512 x i8]* %buf, i32 0, i32 %4
  %5 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %5 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load i32, i32* %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.end
  %7 = load i32, i32* %i, align 4
  %cmp3 = icmp slt i32 %7, 512
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i32, i32* %i, align 4
  %arrayidx5 = getelementptr inbounds [512 x i8], [512 x i8]* %buf, i32 0, i32 %8
  %9 = load i8, i8* %arrayidx5, align 1
  %conv6 = zext i8 %9 to i32
  %call7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i32 0, i32 0), i32 %conv6)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %10, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2, i32 0, i32 0))
  ret void
}

declare dllimport i32 @printf(i8*, ...) #2

; Function Attrs: noinline nounwind
define void @print_bn_arr(i8* %TAG, i8* %array, i32 %len) #0 {
entry:
  %len.addr = alloca i32, align 4
  %array.addr = alloca i8*, align 4
  %TAG.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  store i32 %len, i32* %len.addr, align 4
  store i8* %array, i8** %array.addr, align 4
  store i8* %TAG, i8** %TAG.addr, align 4
  store i32 0, i32* %i, align 4
  %0 = load i8*, i8** %TAG.addr, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.3, i32 0, i32 0), i8* %0)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %1 = load i32, i32* %i, align 4
  %2 = load i8*, i8** %array.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %2, i32 %1
  %3 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %3 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i32, i32* %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.end
  %5 = load i32, i32* %i, align 4
  %6 = load i32, i32* %len.addr, align 4
  %cmp2 = icmp slt i32 %5, %6
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32, i32* %i, align 4
  %8 = load i8*, i8** %array.addr, align 4
  %arrayidx4 = getelementptr inbounds i8, i8* %8, i32 %7
  %9 = load i8, i8* %arrayidx4, align 1
  %conv5 = zext i8 %9 to i32
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i32 %conv5)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %10, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.5, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind
define void @print_array(i8* %TAG, i8* %array, i32 %len) #0 {
entry:
  %len.addr = alloca i32, align 4
  %array.addr = alloca i8*, align 4
  %TAG.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  store i32 %len, i32* %len.addr, align 4
  store i8* %array, i8** %array.addr, align 4
  store i8* %TAG, i8** %TAG.addr, align 4
  %0 = load i32, i32* %len.addr, align 4
  %1 = load i8*, i8** %TAG.addr, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.6, i32 0, i32 0), i8* %1, i32 %0)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %len.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, i32* %i, align 4
  %5 = load i8*, i8** %array.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %5, i32 %4
  %6 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %6 to i32
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i32 0, i32 0), i32 %conv)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32, i32* %i, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8, i32 0, i32 0))
  ret void
}

; Function Attrs: noinline nounwind
define void @print_pk(%struct.rsa_pk_t* %pk) #0 {
entry:
  %pk.addr = alloca %struct.rsa_pk_t*, align 4
  store %struct.rsa_pk_t* %pk, %struct.rsa_pk_t** %pk.addr, align 4
  %0 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %bits = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %0, i32 0, i32 0
  %1 = load i32, i32* %bits, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0), i32 %1)
  %2 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %modulus = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %modulus, i32 0, i32 0
  call void @print_bn_arr(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.10, i32 0, i32 0), i8* %arraydecay, i32 256)
  %3 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %exponent = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %3, i32 0, i32 2
  %arraydecay1 = getelementptr inbounds [256 x i8], [256 x i8]* %exponent, i32 0, i32 0
  call void @print_bn_arr(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.11, i32 0, i32 0), i8* %arraydecay1, i32 256)
  ret void
}

; Function Attrs: noinline nounwind
define void @print_sk(%struct.rsa_sk_t* %sk) #0 {
entry:
  %sk.addr = alloca %struct.rsa_sk_t*, align 4
  store %struct.rsa_sk_t* %sk, %struct.rsa_sk_t** %sk.addr, align 4
  %0 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %bits = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %0, i32 0, i32 0
  %1 = load i32, i32* %bits, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.12, i32 0, i32 0), i32 %1)
  %2 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %modulus = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %modulus, i32 0, i32 0
  call void @print_bn_arr(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.13, i32 0, i32 0), i8* %arraydecay, i32 256)
  %3 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %public_exponet = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %3, i32 0, i32 2
  %arraydecay1 = getelementptr inbounds [256 x i8], [256 x i8]* %public_exponet, i32 0, i32 0
  call void @print_bn_arr(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.14, i32 0, i32 0), i8* %arraydecay1, i32 256)
  %4 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %exponent = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %4, i32 0, i32 3
  %arraydecay2 = getelementptr inbounds [256 x i8], [256 x i8]* %exponent, i32 0, i32 0
  call void @print_bn_arr(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.15, i32 0, i32 0), i8* %arraydecay2, i32 256)
  %5 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %prime1 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %5, i32 0, i32 4
  %arraydecay3 = getelementptr inbounds [128 x i8], [128 x i8]* %prime1, i32 0, i32 0
  call void @print_bn_arr(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.16, i32 0, i32 0), i8* %arraydecay3, i32 128)
  %6 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %prime2 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %6, i32 0, i32 5
  %arraydecay4 = getelementptr inbounds [128 x i8], [128 x i8]* %prime2, i32 0, i32 0
  call void @print_bn_arr(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0), i8* %arraydecay4, i32 128)
  %7 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %prime_exponent1 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %7, i32 0, i32 6
  %arraydecay5 = getelementptr inbounds [128 x i8], [128 x i8]* %prime_exponent1, i32 0, i32 0
  call void @print_bn_arr(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.18, i32 0, i32 0), i8* %arraydecay5, i32 128)
  %8 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %prime_exponent2 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %8, i32 0, i32 7
  %arraydecay6 = getelementptr inbounds [128 x i8], [128 x i8]* %prime_exponent2, i32 0, i32 0
  call void @print_bn_arr(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.19, i32 0, i32 0), i8* %arraydecay6, i32 128)
  %9 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %coefficient = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %9, i32 0, i32 8
  %arraydecay7 = getelementptr inbounds [128 x i8], [128 x i8]* %coefficient, i32 0, i32 0
  call void @print_bn_arr(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.20, i32 0, i32 0), i8* %arraydecay7, i32 128)
  ret void
}

; Function Attrs: noinline nounwind
define i32 @main(i32 %argc, i8** %argv) #0 {
entry:
  %retval = alloca i32, align 4
  %argv.addr = alloca i8**, align 4
  %argc.addr = alloca i32, align 4
  %t = alloca i32, align 4
  %sum = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  store i8** %argv, i8*** %argv.addr, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i32 0, i32* %sum, align 4
  %call = call i32 @clock()
  store i32 %call, i32* %t, align 4
  %call1 = call i32 @test1()
  %call2 = call i32 @test2()
  %call3 = call i32 @test3()
  %call4 = call i32 @clock()
  %0 = load i32, i32* %t, align 4
  %sub = sub nsw i32 %call4, %0
  store i32 %sub, i32* %t, align 4
  %1 = load i32, i32* %t, align 4
  %conv = sitofp i32 %1 to float
  %div = fdiv float %conv, 1.000000e+03
  %conv5 = fpext float %div to double
  %2 = load i32, i32* %sum, align 4
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.21, i32 0, i32 0), i32 %2, double %conv5)
  ret i32 0
}

declare dllimport i32 @clock() #2

; Function Attrs: noinline nounwind
define internal i32 @test1() #0 {
entry:
  %retval = alloca i32, align 4
  %ret = alloca i32, align 4
  %pk = alloca %struct.rsa_pk_t, align 4
  %sk = alloca %struct.rsa_sk_t, align 4
  %output = alloca [256 x i8], align 1
  %input = alloca [256 x i8], align 1
  %msg = alloca [256 x i8], align 1
  %outputLen = alloca i32, align 4
  %inputLen = alloca i32, align 4
  %msg_len = alloca i32, align 4
  %0 = bitcast [256 x i8]* %input to i8*
  call void @llvm.memset.p0i8.i32(i8* %0, i8 0, i32 256, i32 1, i1 false)
  %1 = bitcast i8* %0 to [256 x i8]*
  %2 = getelementptr [256 x i8], [256 x i8]* %1, i32 0, i32 0
  store i8 116, i8* %2
  %3 = getelementptr [256 x i8], [256 x i8]* %1, i32 0, i32 1
  store i8 101, i8* %3
  %4 = getelementptr [256 x i8], [256 x i8]* %1, i32 0, i32 2
  store i8 115, i8* %4
  %5 = getelementptr [256 x i8], [256 x i8]* %1, i32 0, i32 3
  store i8 116, i8* %5
  %call = call i32 @rsa_generate_keys(%struct.rsa_pk_t* %pk, %struct.rsa_sk_t* %sk, i32 512)
  store i32 %call, i32* %ret, align 4
  %6 = load i32, i32* %ret, align 4
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @print_pk(%struct.rsa_pk_t* %pk)
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.22, i32 0, i32 0))
  call void @print_sk(%struct.rsa_sk_t* %sk)
  br label %if.end

if.else:                                          ; preds = %entry
  %7 = load i32, i32* %ret, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.23, i32 0, i32 0), i32 %7)
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %input, i32 0, i32 0
  %call3 = call i32 @strlen(i8* %arraydecay)
  store i32 %call3, i32* %inputLen, align 4
  %8 = load i32, i32* %inputLen, align 4
  %arraydecay4 = getelementptr inbounds [256 x i8], [256 x i8]* %input, i32 0, i32 0
  call void @print_array(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.24, i32 0, i32 0), i8* %arraydecay4, i32 %8)
  %9 = load i32, i32* %inputLen, align 4
  %arraydecay5 = getelementptr inbounds [256 x i8], [256 x i8]* %input, i32 0, i32 0
  %arraydecay6 = getelementptr inbounds [256 x i8], [256 x i8]* %output, i32 0, i32 0
  %call7 = call i32 @rsa_public_encrypt(i8* %arraydecay6, i32* %outputLen, i8* %arraydecay5, i32 %9, %struct.rsa_pk_t* %pk)
  store i32 %call7, i32* %ret, align 4
  %10 = load i32, i32* %ret, align 4
  %cmp8 = icmp eq i32 %10, 0
  br i1 %cmp8, label %if.then9, label %if.else11

if.then9:                                         ; preds = %if.end
  %11 = load i32, i32* %outputLen, align 4
  %arraydecay10 = getelementptr inbounds [256 x i8], [256 x i8]* %output, i32 0, i32 0
  call void @print_array(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.25, i32 0, i32 0), i8* %arraydecay10, i32 %11)
  br label %if.end13

if.else11:                                        ; preds = %if.end
  %12 = load i32, i32* %ret, align 4
  %call12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.26, i32 0, i32 0), i32 %12)
  store i32 -1, i32* %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.then9
  %13 = load i32, i32* %outputLen, align 4
  %arraydecay14 = getelementptr inbounds [256 x i8], [256 x i8]* %output, i32 0, i32 0
  %arraydecay15 = getelementptr inbounds [256 x i8], [256 x i8]* %msg, i32 0, i32 0
  %call16 = call i32 @rsa_private_decrypt(i8* %arraydecay15, i32* %msg_len, i8* %arraydecay14, i32 %13, %struct.rsa_sk_t* %sk)
  store i32 %call16, i32* %ret, align 4
  %14 = load i32, i32* %ret, align 4
  %cmp17 = icmp eq i32 %14, 0
  br i1 %cmp17, label %if.then18, label %if.else22

if.then18:                                        ; preds = %if.end13
  %15 = load i32, i32* %msg_len, align 4
  %arraydecay19 = getelementptr inbounds [256 x i8], [256 x i8]* %msg, i32 0, i32 0
  call void @print_array(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.27, i32 0, i32 0), i8* %arraydecay19, i32 %15)
  %arraydecay20 = getelementptr inbounds [256 x i8], [256 x i8]* %msg, i32 0, i32 0
  %call21 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.28, i32 0, i32 0), i8* %arraydecay20)
  br label %if.end24

if.else22:                                        ; preds = %if.end13
  %16 = load i32, i32* %ret, align 4
  %call23 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.29, i32 0, i32 0), i32 %16)
  store i32 -1, i32* %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.then18
  %17 = load i32, i32* %inputLen, align 4
  %arraydecay25 = getelementptr inbounds [256 x i8], [256 x i8]* %input, i32 0, i32 0
  %arraydecay26 = getelementptr inbounds [256 x i8], [256 x i8]* %output, i32 0, i32 0
  %call27 = call i32 @rsa_private_encrypt(i8* %arraydecay26, i32* %outputLen, i8* %arraydecay25, i32 %17, %struct.rsa_sk_t* %sk)
  store i32 %call27, i32* %ret, align 4
  %18 = load i32, i32* %ret, align 4
  %cmp28 = icmp eq i32 %18, 0
  br i1 %cmp28, label %if.then29, label %if.else31

if.then29:                                        ; preds = %if.end24
  %19 = load i32, i32* %outputLen, align 4
  %arraydecay30 = getelementptr inbounds [256 x i8], [256 x i8]* %output, i32 0, i32 0
  call void @print_array(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.30, i32 0, i32 0), i8* %arraydecay30, i32 %19)
  br label %if.end33

if.else31:                                        ; preds = %if.end24
  %20 = load i32, i32* %ret, align 4
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.31, i32 0, i32 0), i32 %20)
  store i32 -1, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.then29
  %21 = load i32, i32* %outputLen, align 4
  %arraydecay34 = getelementptr inbounds [256 x i8], [256 x i8]* %output, i32 0, i32 0
  %arraydecay35 = getelementptr inbounds [256 x i8], [256 x i8]* %msg, i32 0, i32 0
  %call36 = call i32 @rsa_public_decrypt(i8* %arraydecay35, i32* %msg_len, i8* %arraydecay34, i32 %21, %struct.rsa_pk_t* %pk)
  store i32 %call36, i32* %ret, align 4
  %22 = load i32, i32* %ret, align 4
  %cmp37 = icmp eq i32 %22, 0
  br i1 %cmp37, label %if.then38, label %if.else42

if.then38:                                        ; preds = %if.end33
  %23 = load i32, i32* %msg_len, align 4
  %arraydecay39 = getelementptr inbounds [256 x i8], [256 x i8]* %msg, i32 0, i32 0
  call void @print_array(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.32, i32 0, i32 0), i8* %arraydecay39, i32 %23)
  %arraydecay40 = getelementptr inbounds [256 x i8], [256 x i8]* %msg, i32 0, i32 0
  %call41 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i8* %arraydecay40)
  br label %if.end44

if.else42:                                        ; preds = %if.end33
  %24 = load i32, i32* %ret, align 4
  %call43 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.34, i32 0, i32 0), i32 %24)
  store i32 -1, i32* %retval, align 4
  br label %return

if.end44:                                         ; preds = %if.then38
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end44, %if.else42, %if.else31, %if.else22, %if.else11, %if.else
  %25 = load i32, i32* %retval, align 4
  ret i32 %25
}

declare i32 @strlen(i8*) #2

; Function Attrs: noinline nounwind
define internal i32 @test2() #0 {
entry:
  %retval = alloca i32, align 4
  %ret = alloca i32, align 4
  %pk = alloca %struct.rsa_pk_t, align 4
  %sk = alloca %struct.rsa_sk_t, align 4
  %msg = alloca [256 x i8], align 1
  %msg_len = alloca i32, align 4
  %0 = bitcast %struct.rsa_pk_t* %pk to i8*
  call void @llvm.memset.p0i8.i32(i8* %0, i8 0, i32 516, i32 4, i1 false)
  %1 = bitcast %struct.rsa_sk_t* %sk to i8*
  call void @llvm.memset.p0i8.i32(i8* %1, i8 0, i32 1412, i32 4, i1 false)
  %2 = bitcast [256 x i8]* %msg to i8*
  call void @llvm.memset.p0i8.i32(i8* %2, i8 0, i32 256, i32 1, i1 false)
  %bits = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %pk, i32 0, i32 0
  store i32 2048, i32* %bits, align 4
  %modulus = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %pk, i32 0, i32 1
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %modulus, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arrayidx, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @key_m, i32 0, i32 0), i32 256, i32 1, i1 false)
  %exponent = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %pk, i32 0, i32 2
  %arrayidx1 = getelementptr inbounds [256 x i8], [256 x i8]* %exponent, i32 0, i32 253
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arrayidx1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @key_e, i32 0, i32 0), i32 3, i32 1, i1 false)
  %bits2 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %sk, i32 0, i32 0
  store i32 2048, i32* %bits2, align 4
  %modulus3 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %sk, i32 0, i32 1
  %arrayidx4 = getelementptr inbounds [256 x i8], [256 x i8]* %modulus3, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arrayidx4, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @key_m, i32 0, i32 0), i32 256, i32 1, i1 false)
  %public_exponet = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %sk, i32 0, i32 2
  %arrayidx5 = getelementptr inbounds [256 x i8], [256 x i8]* %public_exponet, i32 0, i32 253
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arrayidx5, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @key_e, i32 0, i32 0), i32 3, i32 1, i1 false)
  %exponent6 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %sk, i32 0, i32 3
  %arrayidx7 = getelementptr inbounds [256 x i8], [256 x i8]* %exponent6, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arrayidx7, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @key_pe, i32 0, i32 0), i32 256, i32 1, i1 false)
  %prime1 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %sk, i32 0, i32 4
  %arrayidx8 = getelementptr inbounds [128 x i8], [128 x i8]* %prime1, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arrayidx8, i8* getelementptr inbounds ([128 x i8], [128 x i8]* @key_p1, i32 0, i32 0), i32 128, i32 1, i1 false)
  %prime2 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %sk, i32 0, i32 5
  %arrayidx9 = getelementptr inbounds [128 x i8], [128 x i8]* %prime2, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arrayidx9, i8* getelementptr inbounds ([128 x i8], [128 x i8]* @key_p2, i32 0, i32 0), i32 128, i32 1, i1 false)
  %prime_exponent1 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %sk, i32 0, i32 6
  %arrayidx10 = getelementptr inbounds [128 x i8], [128 x i8]* %prime_exponent1, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arrayidx10, i8* getelementptr inbounds ([128 x i8], [128 x i8]* @key_e1, i32 0, i32 0), i32 128, i32 1, i1 false)
  %prime_exponent2 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %sk, i32 0, i32 7
  %arrayidx11 = getelementptr inbounds [128 x i8], [128 x i8]* %prime_exponent2, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arrayidx11, i8* getelementptr inbounds ([128 x i8], [128 x i8]* @key_e2, i32 0, i32 0), i32 128, i32 1, i1 false)
  %coefficient = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %sk, i32 0, i32 8
  %arrayidx12 = getelementptr inbounds [128 x i8], [128 x i8]* %coefficient, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arrayidx12, i8* getelementptr inbounds ([128 x i8], [128 x i8]* @key_c, i32 0, i32 0), i32 128, i32 1, i1 false)
  call void @print_pk(%struct.rsa_pk_t* %pk)
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.35, i32 0, i32 0))
  call void @print_sk(%struct.rsa_sk_t* %sk)
  call void @write_sk(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.36, i32 0, i32 0), %struct.rsa_sk_t* %sk)
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %msg, i32 0, i32 0
  %call13 = call i32 @rsa_private_decrypt(i8* %arraydecay, i32* %msg_len, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @hex_array, i32 0, i32 0), i32 256, %struct.rsa_sk_t* %sk)
  store i32 %call13, i32* %ret, align 4
  %3 = load i32, i32* %ret, align 4
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %msg_len, align 4
  %arraydecay14 = getelementptr inbounds [256 x i8], [256 x i8]* %msg, i32 0, i32 0
  call void @print_array(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.37, i32 0, i32 0), i8* %arraydecay14, i32 %4)
  %arraydecay15 = getelementptr inbounds [256 x i8], [256 x i8]* %msg, i32 0, i32 0
  %call16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.38, i32 0, i32 0), i8* %arraydecay15)
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load i32, i32* %ret, align 4
  %call17 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.39, i32 0, i32 0), i32 %5)
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.else
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture readonly, i32, i32, i1) #1

; Function Attrs: noinline nounwind
define internal void @write_sk(i8* %file, %struct.rsa_sk_t* %sk) #0 {
entry:
  %sk.addr = alloca %struct.rsa_sk_t*, align 4
  %file.addr = alloca i8*, align 4
  %fp = alloca %struct._iobuf*, align 4
  store %struct.rsa_sk_t* %sk, %struct.rsa_sk_t** %sk.addr, align 4
  store i8* %file, i8** %file.addr, align 4
  %0 = load i8*, i8** %file.addr, align 4
  %call = call %struct._iobuf* @fopen(i8* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0))
  store %struct._iobuf* %call, %struct._iobuf** %fp, align 4
  %1 = load %struct._iobuf*, %struct._iobuf** %fp, align 4
  %cmp = icmp eq %struct._iobuf* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.41, i32 0, i32 0))
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct._iobuf*, %struct._iobuf** %fp, align 4
  %3 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %4 = bitcast %struct.rsa_sk_t* %3 to i8*
  %call2 = call i32 @fwrite(i8* %4, i32 1, i32 1412, %struct._iobuf* %2)
  %5 = load %struct._iobuf*, %struct._iobuf** %fp, align 4
  %call3 = call i32 @fclose(%struct._iobuf* %5)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare dllimport %struct._iobuf* @fopen(i8*, i8*) #2

declare dllimport i32 @fwrite(i8*, i32, i32, %struct._iobuf*) #2

declare dllimport i32 @fclose(%struct._iobuf*) #2

; Function Attrs: noinline nounwind
define internal i32 @test3() #0 {
entry:
  %retval = alloca i32, align 4
  %sk = alloca %struct.rsa_sk_t, align 4
  %msg = alloca [256 x i8], align 1
  %msg_len = alloca i32, align 4
  %ret = alloca i32, align 4
  %0 = bitcast [256 x i8]* %msg to i8*
  call void @llvm.memset.p0i8.i32(i8* %0, i8 0, i32 256, i32 1, i1 false)
  %call = call i32 @rsa_get_sk_from_file(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.42, i32 0, i32 0), %struct.rsa_sk_t* %sk)
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %msg, i32 0, i32 0
  %call1 = call i32 @rsa_private_decrypt(i8* %arraydecay, i32* %msg_len, i8* getelementptr inbounds ([256 x i8], [256 x i8]* @hex_array, i32 0, i32 0), i32 256, %struct.rsa_sk_t* %sk)
  store i32 %call1, i32* %ret, align 4
  %1 = load i32, i32* %ret, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %msg_len, align 4
  %arraydecay2 = getelementptr inbounds [256 x i8], [256 x i8]* %msg, i32 0, i32 0
  call void @print_array(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.43, i32 0, i32 0), i8* %arraydecay2, i32 %2)
  %arraydecay3 = getelementptr inbounds [256 x i8], [256 x i8]* %msg, i32 0, i32 0
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.44, i32 0, i32 0), i8* %arraydecay3)
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load i32, i32* %ret, align 4
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.45, i32 0, i32 0), i32 %3)
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.else
  %4 = load i32, i32* %retval, align 4
  ret i32 %4
}

; Function Attrs: noinline nounwind
define void @"\01?StartThreadEventForOthread@@YAXH@Z"(i32 %CurID) #0 {
entry:
  %CurID.addr = alloca i32, align 4
  %func = alloca void ()*, align 4
  store i32 %CurID, i32* %CurID.addr, align 4
  br label %while.body

while.body:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %CurID.addr, align 4
  %arrayidx = getelementptr inbounds [20 x i8*], [20 x i8*]* @"\01?hMutexList@@3PAPAXA", i32 0, i32 %0
  %1 = load i8*, i8** %arrayidx, align 4
  %call = call x86_stdcallcc i32 @"\01_WaitForSingleObject@8"(i8* %1, i32 -1)
  %2 = load i32, i32* %CurID.addr, align 4
  %arrayidx1 = getelementptr inbounds [20 x i8*], [20 x i8*]* @"\01?hMutexList@@3PAPAXA", i32 0, i32 %2
  %3 = load i8*, i8** %arrayidx1, align 4
  %call2 = call x86_stdcallcc i32 @"\01_ResetEvent@4"(i8* %3)
  %4 = load i32, i32* @"\01?GlobalSignal@@3HA", align 4
  %5 = load i32, i32* %CurID.addr, align 4
  %arrayidx3 = getelementptr inbounds [20 x [1000 x i32]], [20 x [1000 x i32]]* @"\01?FunctionGrgphForOthread@@3PAY0DOI@HA", i32 0, i32 %5
  %arrayidx4 = getelementptr inbounds [1000 x i32], [1000 x i32]* %arrayidx3, i32 0, i32 %4
  %6 = load i32, i32* %arrayidx4, align 4
  %7 = inttoptr i32 %6 to void ()*
  store void ()* %7, void ()** %func, align 4
  %8 = load void ()*, void ()** %func, align 4
  call void %8()
  %9 = load i32, i32* %CurID.addr, align 4
  %arrayidx5 = getelementptr inbounds [20 x i8*], [20 x i8*]* @"\01?MutexFuncList@@3PAPAXA", i32 0, i32 %9
  %10 = load i8*, i8** %arrayidx5, align 4
  %call6 = call x86_stdcallcc i32 @"\01_SetEvent@4"(i8* %10)
  br label %while.body

return:                                           ; No predecessors!
  ret void
}

declare dllimport x86_stdcallcc i32 @"\01_WaitForSingleObject@8"(i8*, i32) #2

declare dllimport x86_stdcallcc i32 @"\01_ResetEvent@4"(i8*) #2

declare dllimport x86_stdcallcc i32 @"\01_SetEvent@4"(i8*) #2

; Function Attrs: noinline nounwind
define void @"\01?StartThreadWhileForOthread@@YAXH@Z"(i32 %CurID) #0 {
entry:
  %CurID.addr = alloca i32, align 4
  %func = alloca void ()*, align 4
  store i32 %CurID, i32* %CurID.addr, align 4
  br label %while.body

while.body:                                       ; preds = %if.end, %entry
  %0 = load i32, i32* @"\01?GlobalThreadID@@3HA", align 4
  %1 = load i32, i32* %CurID.addr, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %2 = load i32, i32* @"\01?GlobalSignal@@3HA", align 4
  %3 = load i32, i32* %CurID.addr, align 4
  %arrayidx = getelementptr inbounds [20 x [1000 x i32]], [20 x [1000 x i32]]* @"\01?FunctionGrgphForOthread@@3PAY0DOI@HA", i32 0, i32 %3
  %arrayidx1 = getelementptr inbounds [1000 x i32], [1000 x i32]* %arrayidx, i32 0, i32 %2
  %4 = load i32, i32* %arrayidx1, align 4
  %5 = inttoptr i32 %4 to void ()*
  store void ()* %5, void ()** %func, align 4
  %6 = load void ()*, void ()** %func, align 4
  call void %6()
  store i32 -1, i32* @"\01?GlobalThreadID@@3HA", align 4
  %7 = load i32, i32* %CurID.addr, align 4
  %arrayidx2 = getelementptr inbounds [20 x i32], [20 x i32]* @"\01?WhileEndFlag@@3PAHA", i32 0, i32 %7
  store i32 -1, i32* %arrayidx2, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.body

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: noinline nounwind
define void @"\01?MultiThreadForOthread@@YAXH@Z"(i32 %IDLength) #0 {
entry:
  %IDLength.addr = alloca i32, align 4
  %str = alloca [10 x i8], align 1
  %CurID = alloca i32, align 4
  store i32 %IDLength, i32* %IDLength.addr, align 4
  %0 = bitcast [10 x i8]* %str to i8*
  call void @llvm.memset.p0i8.i32(i8* %0, i8 0, i32 10, i32 1, i1 false)
  store i32 0, i32* %CurID, align 4
  store i32 0, i32* %CurID, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %CurID, align 4
  %2 = load i32, i32* %IDLength.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, i32* %CurID, align 4
  %4 = load i32, i32* @"\01?thresholdForOthread@@3HA", align 4
  %cmp1 = icmp slt i32 %3, %4
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %5 = load i32, i32* %CurID, align 4
  %6 = inttoptr i32 %5 to i8*
  %call = call x86_stdcallcc i8* @"\01_CreateThread@24"(%struct._SECURITY_ATTRIBUTES* null, i32 0, i32 (i8*)* bitcast (void (i32)* @"\01?StartThreadWhileForOthread@@YAXH@Z" to i32 (i8*)*), i8* %6, i32 0, i32* null)
  br label %if.end

if.else:                                          ; preds = %for.body
  %arraydecay = getelementptr inbounds [10 x i8], [10 x i8]* %str, i32 0, i32 0
  %7 = load i32, i32* %CurID, align 4
  %call2 = call i8* @itoa(i32 %7, i8* %arraydecay, i32 10)
  %arraydecay3 = getelementptr inbounds [10 x i8], [10 x i8]* %str, i32 0, i32 0
  %8 = bitcast i8* %arraydecay3 to i16*
  %call4 = call x86_stdcallcc i8* @"\01_CreateEventW@16"(%struct._SECURITY_ATTRIBUTES* null, i32 1, i32 0, i16* %8)
  %9 = load i32, i32* %CurID, align 4
  %arrayidx = getelementptr inbounds [20 x i8*], [20 x i8*]* @"\01?hMutexList@@3PAPAXA", i32 0, i32 %9
  store i8* %call4, i8** %arrayidx, align 4
  %arraydecay5 = getelementptr inbounds [10 x i8], [10 x i8]* %str, i32 0, i32 0
  %10 = load i32, i32* %CurID, align 4
  %11 = load i32, i32* @"\01?threadNumForOthread@@3HA", align 4
  %add = add nsw i32 %10, %11
  %add6 = add nsw i32 %add, 1
  %call7 = call i8* @itoa(i32 %add6, i8* %arraydecay5, i32 10)
  %arraydecay8 = getelementptr inbounds [10 x i8], [10 x i8]* %str, i32 0, i32 0
  %12 = bitcast i8* %arraydecay8 to i16*
  %call9 = call x86_stdcallcc i8* @"\01_CreateEventW@16"(%struct._SECURITY_ATTRIBUTES* null, i32 1, i32 0, i16* %12)
  %13 = load i32, i32* %CurID, align 4
  %arrayidx10 = getelementptr inbounds [20 x i8*], [20 x i8*]* @"\01?MutexFuncList@@3PAPAXA", i32 0, i32 %13
  store i8* %call9, i8** %arrayidx10, align 4
  %14 = load i32, i32* %CurID, align 4
  %15 = inttoptr i32 %14 to i8*
  %call11 = call x86_stdcallcc i8* @"\01_CreateThread@24"(%struct._SECURITY_ATTRIBUTES* null, i32 0, i32 (i8*)* bitcast (void (i32)* @"\01?StartThreadEventForOthread@@YAXH@Z" to i32 (i8*)*), i8* %15, i32 0, i32* null)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %16 = load i32, i32* %CurID, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %CurID, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare dllimport x86_stdcallcc i8* @"\01_CreateThread@24"(%struct._SECURITY_ATTRIBUTES*, i32, i32 (i8*)*, i8*, i32, i32*) #2

declare dllimport i8* @itoa(i32, i8*, i32) #2

declare dllimport x86_stdcallcc i8* @"\01_CreateEventW@16"(%struct._SECURITY_ATTRIBUTES*, i32, i32, i16*) #2

; Function Attrs: noinline nounwind
define void @"\01?printNumForOthread@@YAXXZ"() #0 {
entry:
  %j = alloca i32, align 4
  %i = alloca i32, align 4
  %0 = load i32, i32* @"\01?totalnum@@3HA", align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.46, i32 0, i32 0), i32 %0)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc9, %entry
  %1 = load i32, i32* %j, align 4
  %cmp = icmp slt i32 %1, 1000
  br i1 %cmp, label %for.body, label %for.end11

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %i, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* @"\01?threadNumForOthread@@3HA", align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32, i32* %j, align 4
  %5 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds [20 x [1000 x i32]], [20 x [1000 x i32]]* @"\01?CalcCallNumForOthread@@3PAY0DOI@HA", i32 0, i32 %5
  %arrayidx4 = getelementptr inbounds [1000 x i32], [1000 x i32]* %arrayidx, i32 0, i32 %4
  %6 = load i32, i32* %arrayidx4, align 4
  %cmp5 = icmp ne i32 %6, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %for.body3
  %7 = load i32, i32* %j, align 4
  %8 = load i32, i32* %i, align 4
  %arrayidx6 = getelementptr inbounds [20 x [1000 x i32]], [20 x [1000 x i32]]* @"\01?CalcCallNumForOthread@@3PAY0DOI@HA", i32 0, i32 %8
  %arrayidx7 = getelementptr inbounds [1000 x i32], [1000 x i32]* %arrayidx6, i32 0, i32 %7
  %9 = load i32, i32* %arrayidx7, align 4
  %10 = load i32, i32* %j, align 4
  %11 = load i32, i32* %i, align 4
  %call8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1.47, i32 0, i32 0), i32 %11, i32 %10, i32 %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body3
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %12 = load i32, i32* %i, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  br label %for.inc9

for.inc9:                                         ; preds = %for.end
  %13 = load i32, i32* %j, align 4
  %inc10 = add nsw i32 %13, 1
  store i32 %inc10, i32* %j, align 4
  br label %for.cond

for.end11:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: noinline nounwind
define void @"\01?SubOldCallForOthread@@YAXHH@Z"(i32 %tempSignal, i32 %ID) #0 {
entry:
  %ID.addr = alloca i32, align 4
  %tempSignal.addr = alloca i32, align 4
  store i32 %ID, i32* %ID.addr, align 4
  store i32 %tempSignal, i32* %tempSignal.addr, align 4
  %0 = load i32, i32* %tempSignal.addr, align 4
  store i32 %0, i32* @"\01?GlobalSignal@@3HA", align 4
  %1 = load i32, i32* %ID.addr, align 4
  %2 = load i32, i32* @"\01?thresholdForOthread@@3HA", align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %ID.addr, align 4
  store i32 %3, i32* @"\01?GlobalThreadID@@3HA", align 4
  br label %while.body

while.body:                                       ; preds = %if.end, %if.then
  %4 = load i32, i32* %ID.addr, align 4
  %arrayidx = getelementptr inbounds [20 x i32], [20 x i32]* @"\01?WhileEndFlag@@3PAHA", i32 0, i32 %4
  %5 = load i32, i32* %arrayidx, align 4
  %cmp1 = icmp eq i32 %5, -1
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %while.body
  %6 = load i32, i32* %ID.addr, align 4
  %arrayidx3 = getelementptr inbounds [20 x i32], [20 x i32]* @"\01?WhileEndFlag@@3PAHA", i32 0, i32 %6
  store i32 0, i32* %arrayidx3, align 4
  br label %while.end

if.end:                                           ; preds = %while.body
  br label %while.body

while.end:                                        ; preds = %if.then2
  br label %if.end12

if.else:                                          ; preds = %entry
  %7 = load i32, i32* @"\01?totalnum@@3HA", align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, i32* @"\01?totalnum@@3HA", align 4
  %8 = load i32, i32* %tempSignal.addr, align 4
  %9 = load i32, i32* %ID.addr, align 4
  %arrayidx4 = getelementptr inbounds [20 x [1000 x i32]], [20 x [1000 x i32]]* @"\01?CalcCallNumForOthread@@3PAY0DOI@HA", i32 0, i32 %9
  %arrayidx5 = getelementptr inbounds [1000 x i32], [1000 x i32]* %arrayidx4, i32 0, i32 %8
  %10 = load i32, i32* %arrayidx5, align 4
  %inc6 = add nsw i32 %10, 1
  store i32 %inc6, i32* %arrayidx5, align 4
  %11 = load i32, i32* %ID.addr, align 4
  %arrayidx7 = getelementptr inbounds [20 x i8*], [20 x i8*]* @"\01?hMutexList@@3PAPAXA", i32 0, i32 %11
  %12 = load i8*, i8** %arrayidx7, align 4
  %call = call x86_stdcallcc i32 @"\01_SetEvent@4"(i8* %12)
  %13 = load i32, i32* %ID.addr, align 4
  %arrayidx8 = getelementptr inbounds [20 x i8*], [20 x i8*]* @"\01?MutexFuncList@@3PAPAXA", i32 0, i32 %13
  %14 = load i8*, i8** %arrayidx8, align 4
  %call9 = call x86_stdcallcc i32 @"\01_WaitForSingleObject@8"(i8* %14, i32 -1)
  %15 = load i32, i32* %ID.addr, align 4
  %arrayidx10 = getelementptr inbounds [20 x i8*], [20 x i8*]* @"\01?MutexFuncList@@3PAPAXA", i32 0, i32 %15
  %16 = load i8*, i8** %arrayidx10, align 4
  %call11 = call x86_stdcallcc i32 @"\01_ResetEvent@4"(i8* %16)
  br label %if.end12

if.end12:                                         ; preds = %if.else, %while.end
  ret void
}

; Function Attrs: noinline nounwind
define void @initialize_rand() #0 {
entry:
  %call = call i64 @time(i64* null)
  %conv = trunc i64 %call to i32
  call void @srand(i32 %conv)
  ret void
}

; Function Attrs: noinline nounwind
define internal i64 @time(i64* %_Time) #0 {
entry:
  %_Time.addr = alloca i64*, align 4
  store i64* %_Time, i64** %_Time.addr, align 4
  %0 = load i64*, i64** %_Time.addr, align 4
  %call = call i64 @_time64(i64* %0)
  ret i64 %call
}

declare dllimport i64 @_time64(i64*) #2

declare dllimport void @srand(i32) #2

; Function Attrs: noinline nounwind
define void @generate_rand(i8* %block, i32 %block_len) #0 {
entry:
  %block_len.addr = alloca i32, align 4
  %block.addr = alloca i8*, align 4
  %i = alloca i32, align 4
  store i32 %block_len, i32* %block_len.addr, align 4
  store i8* %block, i8** %block.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %block_len.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @rand()
  %conv = trunc i32 %call to i8
  %2 = load i32, i32* %i, align 4
  %3 = load i8*, i8** %block.addr, align 4
  %arrayidx = getelementptr inbounds i8, i8* %3, i32 %2
  store i8 %conv, i8* %arrayidx, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load i32, i32* %i, align 4
  %inc = add i32 %4, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare dllimport i32 @rand() #2

; Function Attrs: noinline nounwind
define i32 @generate_prime(i32* %a, i32* %lower, i32* %upper, i32* %d, i32 %digits) #0 {
entry:
  %retval = alloca i32, align 4
  %digits.addr = alloca i32, align 4
  %d.addr = alloca i32*, align 4
  %upper.addr = alloca i32*, align 4
  %lower.addr = alloca i32*, align 4
  %a.addr = alloca i32*, align 4
  %block = alloca [260 x i8], align 1
  %t = alloca [65 x i32], align 4
  %u = alloca [65 x i32], align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %d, i32** %d.addr, align 4
  store i32* %upper, i32** %upper.addr, align 4
  store i32* %lower, i32** %lower.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %digits.addr, align 4
  %mul = mul i32 %0, 4
  %arraydecay = getelementptr inbounds [260 x i8], [260 x i8]* %block, i32 0, i32 0
  call void @generate_rand(i8* %arraydecay, i32 %mul)
  %1 = load i32, i32* %digits.addr, align 4
  %mul1 = mul i32 %1, 4
  %arraydecay2 = getelementptr inbounds [260 x i8], [260 x i8]* %block, i32 0, i32 0
  %2 = load i32, i32* %digits.addr, align 4
  %3 = load i32*, i32** %a.addr, align 4
  call void @bn_decode(i32* %3, i32 %2, i8* %arraydecay2, i32 %mul1)
  %4 = load i32, i32* %digits.addr, align 4
  %5 = load i32*, i32** %lower.addr, align 4
  %6 = load i32*, i32** %upper.addr, align 4
  %arraydecay3 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %call = call i32 @bn_sub(i32* %arraydecay3, i32* %6, i32* %5, i32 %4)
  %7 = load i32, i32* %digits.addr, align 4
  %arraydecay4 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay4, i32 %7)
  %arrayidx = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  store i32 1, i32* %arrayidx, align 4
  %8 = load i32, i32* %digits.addr, align 4
  %arraydecay5 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %arraydecay6 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay7 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %call8 = call i32 @bn_add(i32* %arraydecay7, i32* %arraydecay6, i32* %arraydecay5, i32 %8)
  %9 = load i32, i32* %digits.addr, align 4
  %arraydecay9 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %10 = load i32, i32* %digits.addr, align 4
  %11 = load i32*, i32** %a.addr, align 4
  %12 = load i32*, i32** %a.addr, align 4
  call void @bn_mod(i32* %12, i32* %11, i32 %10, i32* %arraydecay9, i32 %9)
  %13 = load i32, i32* %digits.addr, align 4
  %14 = load i32*, i32** %lower.addr, align 4
  %15 = load i32*, i32** %a.addr, align 4
  %16 = load i32*, i32** %a.addr, align 4
  %call10 = call i32 @bn_add(i32* %16, i32* %15, i32* %14, i32 %13)
  %17 = load i32, i32* %digits.addr, align 4
  %18 = load i32*, i32** %d.addr, align 4
  %19 = load i32, i32* %digits.addr, align 4
  %20 = load i32*, i32** %a.addr, align 4
  %arraydecay11 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_mod(i32* %arraydecay11, i32* %20, i32 %19, i32* %18, i32 %17)
  %21 = load i32, i32* %digits.addr, align 4
  %arraydecay12 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %22 = load i32*, i32** %a.addr, align 4
  %23 = load i32*, i32** %a.addr, align 4
  %call13 = call i32 @bn_sub(i32* %23, i32* %22, i32* %arraydecay12, i32 %21)
  %24 = load i32, i32* %digits.addr, align 4
  %arraydecay14 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %25 = load i32*, i32** %a.addr, align 4
  %26 = load i32*, i32** %a.addr, align 4
  %call15 = call i32 @bn_add(i32* %26, i32* %25, i32* %arraydecay14, i32 %24)
  %27 = load i32, i32* %digits.addr, align 4
  %28 = load i32*, i32** %lower.addr, align 4
  %29 = load i32*, i32** %a.addr, align 4
  %call16 = call i32 @bn_cmp(i32* %29, i32* %28, i32 %27)
  %cmp = icmp slt i32 %call16, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %30 = load i32, i32* %digits.addr, align 4
  %31 = load i32*, i32** %d.addr, align 4
  %32 = load i32*, i32** %a.addr, align 4
  %33 = load i32*, i32** %a.addr, align 4
  %call17 = call i32 @bn_add(i32* %33, i32* %32, i32* %31, i32 %30)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %34 = load i32, i32* %digits.addr, align 4
  %35 = load i32*, i32** %upper.addr, align 4
  %36 = load i32*, i32** %a.addr, align 4
  %call18 = call i32 @bn_cmp(i32* %36, i32* %35, i32 %34)
  %cmp19 = icmp sgt i32 %call18, 0
  br i1 %cmp19, label %if.then20, label %if.end22

if.then20:                                        ; preds = %if.end
  %37 = load i32, i32* %digits.addr, align 4
  %38 = load i32*, i32** %d.addr, align 4
  %39 = load i32*, i32** %a.addr, align 4
  %40 = load i32*, i32** %a.addr, align 4
  %call21 = call i32 @bn_sub(i32* %40, i32* %39, i32* %38, i32 %37)
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %if.end
  %41 = load i32, i32* %digits.addr, align 4
  %42 = load i32*, i32** %upper.addr, align 4
  %arraydecay23 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay23, i32* %42, i32 %41)
  %43 = load i32, i32* %digits.addr, align 4
  %44 = load i32*, i32** %d.addr, align 4
  %arraydecay24 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay25 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %call26 = call i32 @bn_sub(i32* %arraydecay25, i32* %arraydecay24, i32* %44, i32 %43)
  br label %while.cond

while.cond:                                       ; preds = %if.end32, %if.end22
  %45 = load i32, i32* %digits.addr, align 4
  %46 = load i32*, i32** %a.addr, align 4
  %call27 = call i32 @probable_prime(i32* %46, i32 %45)
  %tobool = icmp ne i32 %call27, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %47 = load i32, i32* %digits.addr, align 4
  %arraydecay28 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %48 = load i32*, i32** %a.addr, align 4
  %call29 = call i32 @bn_cmp(i32* %48, i32* %arraydecay28, i32 %47)
  %cmp30 = icmp sgt i32 %call29, 0
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %while.body
  store i32 4097, i32* %retval, align 4
  br label %return

if.end32:                                         ; preds = %while.body
  %49 = load i32, i32* %digits.addr, align 4
  %50 = load i32*, i32** %d.addr, align 4
  %51 = load i32*, i32** %a.addr, align 4
  %52 = load i32*, i32** %a.addr, align 4
  %call33 = call i32 @bn_add(i32* %52, i32* %51, i32* %50, i32 %49)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %while.end, %if.then31
  %53 = load i32, i32* %retval, align 4
  ret i32 %53
}

; Function Attrs: noinline nounwind
define internal i32 @probable_prime(i32* %a, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %a.addr = alloca i32*, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %digits.addr, align 4
  %1 = load i32*, i32** %a.addr, align 4
  %call = call i32 @small_factor(i32* %1, i32 %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %2 = load i32, i32* %digits.addr, align 4
  %3 = load i32*, i32** %a.addr, align 4
  %call1 = call i32 @fermat_test(i32* %3, i32 %2)
  %tobool2 = icmp ne i32 %call1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %tobool2, %land.rhs ]
  %land.ext = zext i1 %4 to i32
  ret i32 %land.ext
}

; Function Attrs: noinline nounwind
define internal i32 @small_factor(i32* %a, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %a.addr = alloca i32*, align 4
  %status = alloca i32, align 4
  %t = alloca [1 x i32], align 4
  %i = alloca i32, align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  store i32 0, i32* %status, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp ult i32 %0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [1 x i32], [1 x i32]* %t, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay, i32 1)
  %1 = load i32, i32* %i, align 4
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* @SMALL_PRIMES, i32 0, i32 %1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %2 to i32
  %arrayidx1 = getelementptr inbounds [1 x i32], [1 x i32]* %t, i32 0, i32 0
  store i32 %conv, i32* %arrayidx1, align 4
  %3 = load i32, i32* %digits.addr, align 4
  %cmp2 = icmp eq i32 %3, 1
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %arraydecay4 = getelementptr inbounds [1 x i32], [1 x i32]* %t, i32 0, i32 0
  %4 = load i32*, i32** %a.addr, align 4
  %call = call i32 @bn_cmp(i32* %4, i32* %arraydecay4, i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  br label %for.end

if.end:                                           ; preds = %land.lhs.true, %for.body
  %arraydecay5 = getelementptr inbounds [1 x i32], [1 x i32]* %t, i32 0, i32 0
  %5 = load i32, i32* %digits.addr, align 4
  %6 = load i32*, i32** %a.addr, align 4
  %arraydecay6 = getelementptr inbounds [1 x i32], [1 x i32]* %t, i32 0, i32 0
  call void @bn_mod(i32* %arraydecay6, i32* %6, i32 %5, i32* %arraydecay5, i32 1)
  %arraydecay7 = getelementptr inbounds [1 x i32], [1 x i32]* %t, i32 0, i32 0
  %call8 = call i32 @bn_is_zero(i32* %arraydecay7, i32 1)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  store i32 1, i32* %status, align 4
  br label %for.end

if.end11:                                         ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end11
  %7 = load i32, i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then10, %if.then, %for.cond
  store i32 0, i32* %i, align 4
  %arraydecay12 = getelementptr inbounds [1 x i32], [1 x i32]* %t, i32 0, i32 0
  %8 = bitcast i32* %arraydecay12 to i8*
  call void @llvm.memset.p0i8.i32(i8* %8, i8 0, i32 4, i32 4, i1 false)
  %9 = load i32, i32* %status, align 4
  ret i32 %9
}

; Function Attrs: noinline nounwind
define internal i32 @fermat_test(i32* %a, i32 %digits) #0 {
entry:
  %digits.addr = alloca i32, align 4
  %a.addr = alloca i32*, align 4
  %status = alloca i32, align 4
  %t = alloca [65 x i32], align 4
  %u = alloca [65 x i32], align 4
  store i32 %digits, i32* %digits.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %digits.addr, align 4
  %arraydecay = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay, i32 %0)
  %arrayidx = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  store i32 2, i32* %arrayidx, align 4
  %1 = load i32, i32* %digits.addr, align 4
  %2 = load i32*, i32** %a.addr, align 4
  %3 = load i32, i32* %digits.addr, align 4
  %4 = load i32*, i32** %a.addr, align 4
  %arraydecay1 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  call void @bn_mod_exp(i32* %arraydecay2, i32* %arraydecay1, i32* %4, i32 %3, i32* %2, i32 %1)
  %5 = load i32, i32* %digits.addr, align 4
  %arraydecay3 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %call = call i32 @bn_cmp(i32* %arraydecay4, i32* %arraydecay3, i32 %5)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %status, align 4
  %arraydecay5 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %6 = bitcast i32* %arraydecay5 to i8*
  call void @llvm.memset.p0i8.i32(i8* %6, i8 0, i32 260, i32 4, i1 false)
  %7 = load i32, i32* %status, align 4
  ret i32 %7
}

; Function Attrs: noinline nounwind
define i32 @rsa_get_sk_from_file(i8* %file, %struct.rsa_sk_t* %sk) #0 {
entry:
  %retval = alloca i32, align 4
  %sk.addr = alloca %struct.rsa_sk_t*, align 4
  %file.addr = alloca i8*, align 4
  %fp = alloca %struct._iobuf*, align 4
  store %struct.rsa_sk_t* %sk, %struct.rsa_sk_t** %sk.addr, align 4
  store i8* %file, i8** %file.addr, align 4
  %0 = load i8*, i8** %file.addr, align 4
  %call = call %struct._iobuf* @fopen(i8* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.50, i32 0, i32 0))
  store %struct._iobuf* %call, %struct._iobuf** %fp, align 4
  %1 = load %struct._iobuf*, %struct._iobuf** %fp, align 4
  %cmp = icmp eq %struct._iobuf* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct._iobuf*, %struct._iobuf** %fp, align 4
  %3 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %4 = bitcast %struct.rsa_sk_t* %3 to i8*
  %call1 = call i32 @fread(i8* %4, i32 1, i32 1412, %struct._iobuf* %2)
  %5 = load %struct._iobuf*, %struct._iobuf** %fp, align 4
  %call2 = call i32 @fclose(%struct._iobuf* %5)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval, align 4
  ret i32 %6
}

declare dllimport i32 @fread(i8*, i32, i32, %struct._iobuf*) #2

; Function Attrs: noinline nounwind
define i32 @rsa_generate_keys(%struct.rsa_pk_t* %pk, %struct.rsa_sk_t* %sk, i32 %key_bits) #0 {
entry:
  %retval = alloca i32, align 4
  %key_bits.addr = alloca i32, align 4
  %sk.addr = alloca %struct.rsa_sk_t*, align 4
  %pk.addr = alloca %struct.rsa_pk_t*, align 4
  %status = alloca i32, align 4
  %ndigits = alloca i32, align 4
  %pbits = alloca i32, align 4
  %pdigits = alloca i32, align 4
  %qbits = alloca i32, align 4
  %n = alloca [65 x i32], align 4
  %d = alloca [65 x i32], align 4
  %e = alloca [65 x i32], align 4
  %p = alloca [65 x i32], align 4
  %q = alloca [65 x i32], align 4
  %dp = alloca [65 x i32], align 4
  %dq = alloca [65 x i32], align 4
  %phi_n = alloca [65 x i32], align 4
  %q_inv = alloca [65 x i32], align 4
  %p_minus1 = alloca [65 x i32], align 4
  %q_minus1 = alloca [65 x i32], align 4
  %t = alloca [65 x i32], align 4
  %u = alloca [65 x i32], align 4
  %v = alloca [65 x i32], align 4
  store i32 %key_bits, i32* %key_bits.addr, align 4
  store %struct.rsa_sk_t* %sk, %struct.rsa_sk_t** %sk.addr, align 4
  store %struct.rsa_pk_t* %pk, %struct.rsa_pk_t** %pk.addr, align 4
  %0 = load i32, i32* %key_bits.addr, align 4
  %cmp = icmp ult i32 %0, 508
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %key_bits.addr, align 4
  %cmp1 = icmp ugt i32 %1, 2048
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 4098, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32, i32* %key_bits.addr, align 4
  %add = add i32 %2, 32
  %sub = sub i32 %add, 1
  %div = udiv i32 %sub, 32
  store i32 %div, i32* %ndigits, align 4
  %3 = load i32, i32* %ndigits, align 4
  %add2 = add i32 %3, 1
  %div3 = udiv i32 %add2, 2
  store i32 %div3, i32* %pdigits, align 4
  %4 = load i32, i32* %key_bits.addr, align 4
  %add4 = add i32 %4, 1
  %div5 = udiv i32 %add4, 2
  store i32 %div5, i32* %pbits, align 4
  %5 = load i32, i32* %key_bits.addr, align 4
  %6 = load i32, i32* %pbits, align 4
  %sub6 = sub i32 %5, %6
  store i32 %sub6, i32* %qbits, align 4
  call void @initialize_rand()
  %7 = load i32, i32* %ndigits, align 4
  %arraydecay = getelementptr inbounds [65 x i32], [65 x i32]* %e, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay, i32 %7)
  %arrayidx = getelementptr inbounds [65 x i32], [65 x i32]* %e, i32 0, i32 0
  store i32 65537, i32* %arrayidx, align 4
  %8 = load i32, i32* %pdigits, align 4
  %9 = load i32, i32* %pbits, align 4
  %sub7 = sub i32 %9, 1
  %arraydecay8 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_assign_2exp(i32* %arraydecay8, i32 %sub7, i32 %8)
  %10 = load i32, i32* %pdigits, align 4
  %11 = load i32, i32* %pbits, align 4
  %sub9 = sub i32 %11, 2
  %arraydecay10 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  call void @bn_assign_2exp(i32* %arraydecay10, i32 %sub9, i32 %10)
  %12 = load i32, i32* %pdigits, align 4
  %arraydecay11 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %arraydecay12 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay13 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %call = call i32 @bn_add(i32* %arraydecay13, i32* %arraydecay12, i32* %arraydecay11, i32 %12)
  %13 = load i32, i32* %pdigits, align 4
  %arraydecay14 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay14, i32 %13)
  %arrayidx15 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  store i32 1, i32* %arrayidx15, align 4
  %14 = load i32, i32* %pdigits, align 4
  %arraydecay16 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay18 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  %call19 = call i32 @bn_sub(i32* %arraydecay18, i32* %arraydecay17, i32* %arraydecay16, i32 %14)
  %15 = load i32, i32* %pdigits, align 4
  %arraydecay20 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  %arraydecay21 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %arraydecay22 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %call23 = call i32 @bn_add(i32* %arraydecay22, i32* %arraydecay21, i32* %arraydecay20, i32 %15)
  %16 = load i32, i32* %pdigits, align 4
  %arraydecay24 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay24, i32 %16)
  %arrayidx25 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  store i32 2, i32* %arrayidx25, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end
  %17 = load i32, i32* %pdigits, align 4
  %arraydecay26 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  %arraydecay27 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %arraydecay28 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay29 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %call30 = call i32 @generate_prime(i32* %arraydecay29, i32* %arraydecay28, i32* %arraydecay27, i32* %arraydecay26, i32 %17)
  store i32 %call30, i32* %status, align 4
  %18 = load i32, i32* %status, align 4
  %cmp31 = icmp ne i32 %18, 0
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %do.body
  %19 = load i32, i32* %status, align 4
  store i32 %19, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end33
  %arraydecay34 = getelementptr inbounds [65 x i32], [65 x i32]* %e, i32 0, i32 0
  %20 = load i32, i32* %pdigits, align 4
  %arraydecay35 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %call36 = call i32 @rsa_filter(i32* %arraydecay35, i32 %20, i32* %arraydecay34, i32 1)
  %tobool = icmp ne i32 %call36, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %21 = load i32, i32* %pdigits, align 4
  %22 = load i32, i32* %qbits, align 4
  %sub37 = sub i32 %22, 1
  %arraydecay38 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_assign_2exp(i32* %arraydecay38, i32 %sub37, i32 %21)
  %23 = load i32, i32* %pdigits, align 4
  %24 = load i32, i32* %qbits, align 4
  %sub39 = sub i32 %24, 2
  %arraydecay40 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  call void @bn_assign_2exp(i32* %arraydecay40, i32 %sub39, i32 %23)
  %25 = load i32, i32* %pdigits, align 4
  %arraydecay41 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %arraydecay42 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay43 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %call44 = call i32 @bn_add(i32* %arraydecay43, i32* %arraydecay42, i32* %arraydecay41, i32 %25)
  %26 = load i32, i32* %pdigits, align 4
  %arraydecay45 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay45, i32 %26)
  %arrayidx46 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  store i32 1, i32* %arrayidx46, align 4
  %27 = load i32, i32* %pdigits, align 4
  %arraydecay47 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  %arraydecay48 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay49 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  %call50 = call i32 @bn_sub(i32* %arraydecay49, i32* %arraydecay48, i32* %arraydecay47, i32 %27)
  %28 = load i32, i32* %pdigits, align 4
  %arraydecay51 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  %arraydecay52 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %arraydecay53 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %call54 = call i32 @bn_add(i32* %arraydecay53, i32* %arraydecay52, i32* %arraydecay51, i32 %28)
  %29 = load i32, i32* %pdigits, align 4
  %arraydecay55 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay55, i32 %29)
  %arrayidx56 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  store i32 2, i32* %arrayidx56, align 4
  br label %do.body57

do.body57:                                        ; preds = %do.cond66, %do.end
  %30 = load i32, i32* %pdigits, align 4
  %arraydecay58 = getelementptr inbounds [65 x i32], [65 x i32]* %v, i32 0, i32 0
  %arraydecay59 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %arraydecay60 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay61 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %call62 = call i32 @generate_prime(i32* %arraydecay61, i32* %arraydecay60, i32* %arraydecay59, i32* %arraydecay58, i32 %30)
  store i32 %call62, i32* %status, align 4
  %31 = load i32, i32* %status, align 4
  %cmp63 = icmp ne i32 %31, 0
  br i1 %cmp63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %do.body57
  %32 = load i32, i32* %status, align 4
  store i32 %32, i32* %retval, align 4
  br label %return

if.end65:                                         ; preds = %do.body57
  br label %do.cond66

do.cond66:                                        ; preds = %if.end65
  %arraydecay67 = getelementptr inbounds [65 x i32], [65 x i32]* %e, i32 0, i32 0
  %33 = load i32, i32* %pdigits, align 4
  %arraydecay68 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %call69 = call i32 @rsa_filter(i32* %arraydecay68, i32 %33, i32* %arraydecay67, i32 1)
  %tobool70 = icmp ne i32 %call69, 0
  %lnot71 = xor i1 %tobool70, true
  br i1 %lnot71, label %do.body57, label %do.end72

do.end72:                                         ; preds = %do.cond66
  %34 = load i32, i32* %pdigits, align 4
  %arraydecay73 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %arraydecay74 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %call75 = call i32 @bn_cmp(i32* %arraydecay74, i32* %arraydecay73, i32 %34)
  %cmp76 = icmp slt i32 %call75, 0
  br i1 %cmp76, label %if.then77, label %if.end84

if.then77:                                        ; preds = %do.end72
  %35 = load i32, i32* %pdigits, align 4
  %arraydecay78 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %arraydecay79 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay79, i32* %arraydecay78, i32 %35)
  %36 = load i32, i32* %pdigits, align 4
  %arraydecay80 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %arraydecay81 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay81, i32* %arraydecay80, i32 %36)
  %37 = load i32, i32* %pdigits, align 4
  %arraydecay82 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay83 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay83, i32* %arraydecay82, i32 %37)
  br label %if.end84

if.end84:                                         ; preds = %if.then77, %do.end72
  %38 = load i32, i32* %pdigits, align 4
  %arraydecay85 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %arraydecay86 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %arraydecay87 = getelementptr inbounds [65 x i32], [65 x i32]* %n, i32 0, i32 0
  call void @bn_mul(i32* %arraydecay87, i32* %arraydecay86, i32* %arraydecay85, i32 %38)
  %39 = load i32, i32* %pdigits, align 4
  %arraydecay88 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %arraydecay89 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %arraydecay90 = getelementptr inbounds [65 x i32], [65 x i32]* %q_inv, i32 0, i32 0
  call void @bn_mod_inv(i32* %arraydecay90, i32* %arraydecay89, i32* %arraydecay88, i32 %39)
  %40 = load i32, i32* %pdigits, align 4
  %arraydecay91 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay91, i32 %40)
  %arrayidx92 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  store i32 1, i32* %arrayidx92, align 4
  %41 = load i32, i32* %pdigits, align 4
  %arraydecay93 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay94 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %arraydecay95 = getelementptr inbounds [65 x i32], [65 x i32]* %p_minus1, i32 0, i32 0
  %call96 = call i32 @bn_sub(i32* %arraydecay95, i32* %arraydecay94, i32* %arraydecay93, i32 %41)
  %42 = load i32, i32* %pdigits, align 4
  %arraydecay97 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay98 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %arraydecay99 = getelementptr inbounds [65 x i32], [65 x i32]* %q_minus1, i32 0, i32 0
  %call100 = call i32 @bn_sub(i32* %arraydecay99, i32* %arraydecay98, i32* %arraydecay97, i32 %42)
  %43 = load i32, i32* %pdigits, align 4
  %arraydecay101 = getelementptr inbounds [65 x i32], [65 x i32]* %q_minus1, i32 0, i32 0
  %arraydecay102 = getelementptr inbounds [65 x i32], [65 x i32]* %p_minus1, i32 0, i32 0
  %arraydecay103 = getelementptr inbounds [65 x i32], [65 x i32]* %phi_n, i32 0, i32 0
  call void @bn_mul(i32* %arraydecay103, i32* %arraydecay102, i32* %arraydecay101, i32 %43)
  %44 = load i32, i32* %ndigits, align 4
  %arraydecay104 = getelementptr inbounds [65 x i32], [65 x i32]* %phi_n, i32 0, i32 0
  %arraydecay105 = getelementptr inbounds [65 x i32], [65 x i32]* %e, i32 0, i32 0
  %arraydecay106 = getelementptr inbounds [65 x i32], [65 x i32]* %d, i32 0, i32 0
  call void @bn_mod_inv(i32* %arraydecay106, i32* %arraydecay105, i32* %arraydecay104, i32 %44)
  %45 = load i32, i32* %pdigits, align 4
  %arraydecay107 = getelementptr inbounds [65 x i32], [65 x i32]* %p_minus1, i32 0, i32 0
  %46 = load i32, i32* %ndigits, align 4
  %arraydecay108 = getelementptr inbounds [65 x i32], [65 x i32]* %d, i32 0, i32 0
  %arraydecay109 = getelementptr inbounds [65 x i32], [65 x i32]* %dp, i32 0, i32 0
  call void @bn_mod(i32* %arraydecay109, i32* %arraydecay108, i32 %46, i32* %arraydecay107, i32 %45)
  %47 = load i32, i32* %pdigits, align 4
  %arraydecay110 = getelementptr inbounds [65 x i32], [65 x i32]* %q_minus1, i32 0, i32 0
  %48 = load i32, i32* %ndigits, align 4
  %arraydecay111 = getelementptr inbounds [65 x i32], [65 x i32]* %d, i32 0, i32 0
  %arraydecay112 = getelementptr inbounds [65 x i32], [65 x i32]* %dq, i32 0, i32 0
  call void @bn_mod(i32* %arraydecay112, i32* %arraydecay111, i32 %48, i32* %arraydecay110, i32 %47)
  %49 = load i32, i32* %key_bits.addr, align 4
  %50 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %bits = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %50, i32 0, i32 0
  store i32 %49, i32* %bits, align 4
  %51 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %bits113 = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %51, i32 0, i32 0
  store i32 %49, i32* %bits113, align 4
  %52 = load i32, i32* %ndigits, align 4
  %arraydecay114 = getelementptr inbounds [65 x i32], [65 x i32]* %n, i32 0, i32 0
  %53 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %modulus = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %53, i32 0, i32 1
  %arraydecay115 = getelementptr inbounds [256 x i8], [256 x i8]* %modulus, i32 0, i32 0
  call void @bn_encode(i8* %arraydecay115, i32 256, i32* %arraydecay114, i32 %52)
  %arraydecay116 = getelementptr inbounds [65 x i32], [65 x i32]* %e, i32 0, i32 0
  %54 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %exponent = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %54, i32 0, i32 2
  %arraydecay117 = getelementptr inbounds [256 x i8], [256 x i8]* %exponent, i32 0, i32 0
  call void @bn_encode(i8* %arraydecay117, i32 256, i32* %arraydecay116, i32 1)
  %55 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %modulus118 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %55, i32 0, i32 1
  %arraydecay119 = getelementptr inbounds [256 x i8], [256 x i8]* %modulus118, i32 0, i32 0
  %56 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %modulus120 = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %56, i32 0, i32 1
  %arraydecay121 = getelementptr inbounds [256 x i8], [256 x i8]* %modulus120, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arraydecay119, i8* %arraydecay121, i32 256, i32 4, i1 false)
  %57 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %public_exponet = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %57, i32 0, i32 2
  %arraydecay122 = getelementptr inbounds [256 x i8], [256 x i8]* %public_exponet, i32 0, i32 0
  %58 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %exponent123 = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %58, i32 0, i32 2
  %arraydecay124 = getelementptr inbounds [256 x i8], [256 x i8]* %exponent123, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arraydecay122, i8* %arraydecay124, i32 256, i32 4, i1 false)
  %59 = load i32, i32* %ndigits, align 4
  %arraydecay125 = getelementptr inbounds [65 x i32], [65 x i32]* %d, i32 0, i32 0
  %60 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %exponent126 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %60, i32 0, i32 3
  %arraydecay127 = getelementptr inbounds [256 x i8], [256 x i8]* %exponent126, i32 0, i32 0
  call void @bn_encode(i8* %arraydecay127, i32 256, i32* %arraydecay125, i32 %59)
  %61 = load i32, i32* %pdigits, align 4
  %arraydecay128 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %62 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %prime1 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %62, i32 0, i32 4
  %arraydecay129 = getelementptr inbounds [128 x i8], [128 x i8]* %prime1, i32 0, i32 0
  call void @bn_encode(i8* %arraydecay129, i32 128, i32* %arraydecay128, i32 %61)
  %63 = load i32, i32* %pdigits, align 4
  %arraydecay130 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %64 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %prime2 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %64, i32 0, i32 5
  %arraydecay131 = getelementptr inbounds [128 x i8], [128 x i8]* %prime2, i32 0, i32 0
  call void @bn_encode(i8* %arraydecay131, i32 128, i32* %arraydecay130, i32 %63)
  %65 = load i32, i32* %pdigits, align 4
  %arraydecay132 = getelementptr inbounds [65 x i32], [65 x i32]* %dp, i32 0, i32 0
  %66 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %prime_exponent1 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %66, i32 0, i32 6
  %arraydecay133 = getelementptr inbounds [128 x i8], [128 x i8]* %prime_exponent1, i32 0, i32 0
  call void @bn_encode(i8* %arraydecay133, i32 128, i32* %arraydecay132, i32 %65)
  %67 = load i32, i32* %pdigits, align 4
  %arraydecay134 = getelementptr inbounds [65 x i32], [65 x i32]* %dq, i32 0, i32 0
  %68 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %prime_exponent2 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %68, i32 0, i32 7
  %arraydecay135 = getelementptr inbounds [128 x i8], [128 x i8]* %prime_exponent2, i32 0, i32 0
  call void @bn_encode(i8* %arraydecay135, i32 128, i32* %arraydecay134, i32 %67)
  %69 = load i32, i32* %pdigits, align 4
  %arraydecay136 = getelementptr inbounds [65 x i32], [65 x i32]* %q_inv, i32 0, i32 0
  %70 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %coefficient = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %70, i32 0, i32 8
  %arraydecay137 = getelementptr inbounds [128 x i8], [128 x i8]* %coefficient, i32 0, i32 0
  call void @bn_encode(i8* %arraydecay137, i32 128, i32* %arraydecay136, i32 %69)
  %arraydecay138 = getelementptr inbounds [65 x i32], [65 x i32]* %d, i32 0, i32 0
  %71 = bitcast i32* %arraydecay138 to i8*
  call void @llvm.memset.p0i8.i32(i8* %71, i8 0, i32 260, i32 4, i1 false)
  %arraydecay139 = getelementptr inbounds [65 x i32], [65 x i32]* %dp, i32 0, i32 0
  %72 = bitcast i32* %arraydecay139 to i8*
  call void @llvm.memset.p0i8.i32(i8* %72, i8 0, i32 260, i32 4, i1 false)
  %arraydecay140 = getelementptr inbounds [65 x i32], [65 x i32]* %dq, i32 0, i32 0
  %73 = bitcast i32* %arraydecay140 to i8*
  call void @llvm.memset.p0i8.i32(i8* %73, i8 0, i32 260, i32 4, i1 false)
  %arraydecay141 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %74 = bitcast i32* %arraydecay141 to i8*
  call void @llvm.memset.p0i8.i32(i8* %74, i8 0, i32 260, i32 4, i1 false)
  %arraydecay142 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %75 = bitcast i32* %arraydecay142 to i8*
  call void @llvm.memset.p0i8.i32(i8* %75, i8 0, i32 260, i32 4, i1 false)
  %arraydecay143 = getelementptr inbounds [65 x i32], [65 x i32]* %phi_n, i32 0, i32 0
  %76 = bitcast i32* %arraydecay143 to i8*
  call void @llvm.memset.p0i8.i32(i8* %76, i8 0, i32 260, i32 4, i1 false)
  %arraydecay144 = getelementptr inbounds [65 x i32], [65 x i32]* %q_inv, i32 0, i32 0
  %77 = bitcast i32* %arraydecay144 to i8*
  call void @llvm.memset.p0i8.i32(i8* %77, i8 0, i32 260, i32 4, i1 false)
  %arraydecay145 = getelementptr inbounds [65 x i32], [65 x i32]* %p_minus1, i32 0, i32 0
  %78 = bitcast i32* %arraydecay145 to i8*
  call void @llvm.memset.p0i8.i32(i8* %78, i8 0, i32 260, i32 4, i1 false)
  %arraydecay146 = getelementptr inbounds [65 x i32], [65 x i32]* %q_minus1, i32 0, i32 0
  %79 = bitcast i32* %arraydecay146 to i8*
  call void @llvm.memset.p0i8.i32(i8* %79, i8 0, i32 260, i32 4, i1 false)
  %arraydecay147 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %80 = bitcast i32* %arraydecay147 to i8*
  call void @llvm.memset.p0i8.i32(i8* %80, i8 0, i32 260, i32 4, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end84, %if.then64, %if.then32, %if.then
  %81 = load i32, i32* %retval, align 4
  ret i32 %81
}

; Function Attrs: noinline nounwind
define internal i32 @rsa_filter(i32* %a, i32 %adigits, i32* %b, i32 %bdigits) #0 {
entry:
  %bdigits.addr = alloca i32, align 4
  %b.addr = alloca i32*, align 4
  %adigits.addr = alloca i32, align 4
  %a.addr = alloca i32*, align 4
  %status = alloca i32, align 4
  %a_minus1 = alloca [65 x i32], align 4
  %t = alloca [65 x i32], align 4
  store i32 %bdigits, i32* %bdigits.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32 %adigits, i32* %adigits.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %adigits.addr, align 4
  %arraydecay = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay, i32 %0)
  %arrayidx = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  store i32 1, i32* %arrayidx, align 4
  %1 = load i32, i32* %adigits.addr, align 4
  %arraydecay1 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %2 = load i32*, i32** %a.addr, align 4
  %arraydecay2 = getelementptr inbounds [65 x i32], [65 x i32]* %a_minus1, i32 0, i32 0
  %call = call i32 @bn_sub(i32* %arraydecay2, i32* %2, i32* %arraydecay1, i32 %1)
  %3 = load i32, i32* %bdigits.addr, align 4
  %4 = load i32*, i32** %b.addr, align 4
  %5 = load i32, i32* %adigits.addr, align 4
  %arraydecay3 = getelementptr inbounds [65 x i32], [65 x i32]* %a_minus1, i32 0, i32 0
  %call4 = call i32 @relatively_prime(i32* %arraydecay3, i32 %5, i32* %4, i32 %3)
  store i32 %call4, i32* %status, align 4
  %arraydecay5 = getelementptr inbounds [65 x i32], [65 x i32]* %a_minus1, i32 0, i32 0
  %6 = bitcast i32* %arraydecay5 to i8*
  call void @llvm.memset.p0i8.i32(i8* %6, i8 0, i32 260, i32 4, i1 false)
  %7 = load i32, i32* %status, align 4
  ret i32 %7
}

; Function Attrs: noinline nounwind
define internal i32 @relatively_prime(i32* %a, i32 %adigits, i32* %b, i32 %bdigits) #0 {
entry:
  %bdigits.addr = alloca i32, align 4
  %b.addr = alloca i32*, align 4
  %adigits.addr = alloca i32, align 4
  %a.addr = alloca i32*, align 4
  %status = alloca i32, align 4
  %t = alloca [65 x i32], align 4
  %u = alloca [65 x i32], align 4
  store i32 %bdigits, i32* %bdigits.addr, align 4
  store i32* %b, i32** %b.addr, align 4
  store i32 %adigits, i32* %adigits.addr, align 4
  store i32* %a, i32** %a.addr, align 4
  %0 = load i32, i32* %adigits.addr, align 4
  %arraydecay = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay, i32 %0)
  %1 = load i32, i32* %bdigits.addr, align 4
  %2 = load i32*, i32** %b.addr, align 4
  %arraydecay1 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_assign(i32* %arraydecay1, i32* %2, i32 %1)
  %3 = load i32, i32* %adigits.addr, align 4
  %arraydecay2 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %4 = load i32*, i32** %a.addr, align 4
  %arraydecay3 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_gcd(i32* %arraydecay3, i32* %4, i32* %arraydecay2, i32 %3)
  %5 = load i32, i32* %adigits.addr, align 4
  %arraydecay4 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay4, i32 %5)
  %arrayidx = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  store i32 1, i32* %arrayidx, align 4
  %6 = load i32, i32* %adigits.addr, align 4
  %arraydecay5 = getelementptr inbounds [65 x i32], [65 x i32]* %u, i32 0, i32 0
  %arraydecay6 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %call = call i32 @bn_cmp(i32* %arraydecay6, i32* %arraydecay5, i32 %6)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %status, align 4
  %arraydecay7 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %7 = bitcast i32* %arraydecay7 to i8*
  call void @llvm.memset.p0i8.i32(i8* %7, i8 0, i32 260, i32 4, i1 false)
  %8 = load i32, i32* %status, align 4
  ret i32 %8
}

; Function Attrs: noinline nounwind
define i32 @rsa_public_encrypt(i8* %out, i32* %out_len, i8* %in, i32 %in_len, %struct.rsa_pk_t* %pk) #0 {
entry:
  %retval = alloca i32, align 4
  %pk.addr = alloca %struct.rsa_pk_t*, align 4
  %in_len.addr = alloca i32, align 4
  %in.addr = alloca i8*, align 4
  %out_len.addr = alloca i32*, align 4
  %out.addr = alloca i8*, align 4
  %status = alloca i32, align 4
  %byte = alloca i8, align 1
  %pkcs_block = alloca [256 x i8], align 1
  %i = alloca i32, align 4
  %modulus_len = alloca i32, align 4
  store %struct.rsa_pk_t* %pk, %struct.rsa_pk_t** %pk.addr, align 4
  store i32 %in_len, i32* %in_len.addr, align 4
  store i8* %in, i8** %in.addr, align 4
  store i32* %out_len, i32** %out_len.addr, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %bits = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %0, i32 0, i32 0
  %1 = load i32, i32* %bits, align 4
  %add = add i32 %1, 7
  %div = udiv i32 %add, 8
  store i32 %div, i32* %modulus_len, align 4
  %2 = load i32, i32* %in_len.addr, align 4
  %add1 = add i32 %2, 11
  %3 = load i32, i32* %modulus_len, align 4
  %cmp = icmp ugt i32 %add1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 4098, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 0
  store i8 0, i8* %arrayidx, align 1
  %arrayidx2 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 1
  store i8 2, i8* %arrayidx2, align 1
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* %modulus_len, align 4
  %6 = load i32, i32* %in_len.addr, align 4
  %sub = sub i32 %5, %6
  %sub3 = sub i32 %sub, 1
  %cmp4 = icmp ult i32 %4, %sub3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %do.cond, %for.body
  call void @generate_rand(i8* %byte, i32 1)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %7 = load i8, i8* %byte, align 1
  %conv = zext i8 %7 to i32
  %cmp5 = icmp eq i32 %conv, 0
  br i1 %cmp5, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %8 = load i8, i8* %byte, align 1
  %9 = load i32, i32* %i, align 4
  %arrayidx7 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 %9
  store i8 %8, i8* %arrayidx7, align 1
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %10 = load i32, i32* %i, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load i32, i32* %i, align 4
  %inc8 = add i32 %11, 1
  store i32 %inc8, i32* %i, align 4
  %arrayidx9 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 %11
  store i8 0, i8* %arrayidx9, align 1
  %12 = load i32, i32* %i, align 4
  %arrayidx10 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 %12
  %13 = load i8*, i8** %in.addr, align 4
  %14 = load i32, i32* %in_len.addr, align 4
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arrayidx10, i8* %13, i32 %14, i32 1, i1 false)
  %15 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %16 = load i32, i32* %modulus_len, align 4
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 0
  %17 = load i32*, i32** %out_len.addr, align 4
  %18 = load i8*, i8** %out.addr, align 4
  %call = call i32 @public_block_operation(i8* %18, i32* %17, i8* %arraydecay, i32 %16, %struct.rsa_pk_t* %15)
  store i32 %call, i32* %status, align 4
  store i8 0, i8* %byte, align 1
  %arraydecay11 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 0
  call void @llvm.memset.p0i8.i32(i8* %arraydecay11, i8 0, i32 256, i32 1, i1 false)
  %19 = load i32, i32* %status, align 4
  store i32 %19, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %20 = load i32, i32* %retval, align 4
  ret i32 %20
}

; Function Attrs: noinline nounwind
define internal i32 @public_block_operation(i8* %out, i32* %out_len, i8* %in, i32 %in_len, %struct.rsa_pk_t* %pk) #0 {
entry:
  %retval = alloca i32, align 4
  %pk.addr = alloca %struct.rsa_pk_t*, align 4
  %in_len.addr = alloca i32, align 4
  %in.addr = alloca i8*, align 4
  %out_len.addr = alloca i32*, align 4
  %out.addr = alloca i8*, align 4
  %edigits = alloca i32, align 4
  %ndigits = alloca i32, align 4
  %c = alloca [65 x i32], align 4
  %e = alloca [65 x i32], align 4
  %m = alloca [65 x i32], align 4
  %n = alloca [65 x i32], align 4
  store %struct.rsa_pk_t* %pk, %struct.rsa_pk_t** %pk.addr, align 4
  store i32 %in_len, i32* %in_len.addr, align 4
  store i8* %in, i8** %in.addr, align 4
  store i32* %out_len, i32** %out_len.addr, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i32, i32* %in_len.addr, align 4
  %1 = load i8*, i8** %in.addr, align 4
  %arraydecay = getelementptr inbounds [65 x i32], [65 x i32]* %m, i32 0, i32 0
  call void @bn_decode(i32* %arraydecay, i32 65, i8* %1, i32 %0)
  %2 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %modulus = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %2, i32 0, i32 1
  %arraydecay1 = getelementptr inbounds [256 x i8], [256 x i8]* %modulus, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [65 x i32], [65 x i32]* %n, i32 0, i32 0
  call void @bn_decode(i32* %arraydecay2, i32 65, i8* %arraydecay1, i32 256)
  %3 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %exponent = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %3, i32 0, i32 2
  %arraydecay3 = getelementptr inbounds [256 x i8], [256 x i8]* %exponent, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [65 x i32], [65 x i32]* %e, i32 0, i32 0
  call void @bn_decode(i32* %arraydecay4, i32 65, i8* %arraydecay3, i32 256)
  %arraydecay5 = getelementptr inbounds [65 x i32], [65 x i32]* %n, i32 0, i32 0
  %call = call i32 @bn_digits(i32* %arraydecay5, i32 65)
  store i32 %call, i32* %ndigits, align 4
  %arraydecay6 = getelementptr inbounds [65 x i32], [65 x i32]* %e, i32 0, i32 0
  %call7 = call i32 @bn_digits(i32* %arraydecay6, i32 65)
  store i32 %call7, i32* %edigits, align 4
  %4 = load i32, i32* %ndigits, align 4
  %arraydecay8 = getelementptr inbounds [65 x i32], [65 x i32]* %n, i32 0, i32 0
  %arraydecay9 = getelementptr inbounds [65 x i32], [65 x i32]* %m, i32 0, i32 0
  %call10 = call i32 @bn_cmp(i32* %arraydecay9, i32* %arraydecay8, i32 %4)
  %cmp = icmp sge i32 %call10, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 4097, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, i32* %ndigits, align 4
  %arraydecay11 = getelementptr inbounds [65 x i32], [65 x i32]* %n, i32 0, i32 0
  %6 = load i32, i32* %edigits, align 4
  %arraydecay12 = getelementptr inbounds [65 x i32], [65 x i32]* %e, i32 0, i32 0
  %arraydecay13 = getelementptr inbounds [65 x i32], [65 x i32]* %m, i32 0, i32 0
  %arraydecay14 = getelementptr inbounds [65 x i32], [65 x i32]* %c, i32 0, i32 0
  call void @bn_mod_exp(i32* %arraydecay14, i32* %arraydecay13, i32* %arraydecay12, i32 %6, i32* %arraydecay11, i32 %5)
  %7 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %bits = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %7, i32 0, i32 0
  %8 = load i32, i32* %bits, align 4
  %add = add i32 %8, 7
  %div = udiv i32 %add, 8
  %9 = load i32*, i32** %out_len.addr, align 4
  store i32 %div, i32* %9, align 4
  %10 = load i32, i32* %ndigits, align 4
  %arraydecay15 = getelementptr inbounds [65 x i32], [65 x i32]* %c, i32 0, i32 0
  %11 = load i32*, i32** %out_len.addr, align 4
  %12 = load i32, i32* %11, align 4
  %13 = load i8*, i8** %out.addr, align 4
  call void @bn_encode(i8* %13, i32 %12, i32* %arraydecay15, i32 %10)
  %arraydecay16 = getelementptr inbounds [65 x i32], [65 x i32]* %c, i32 0, i32 0
  %14 = bitcast i32* %arraydecay16 to i8*
  call void @llvm.memset.p0i8.i32(i8* %14, i8 0, i32 260, i32 4, i1 false)
  %arraydecay17 = getelementptr inbounds [65 x i32], [65 x i32]* %m, i32 0, i32 0
  %15 = bitcast i32* %arraydecay17 to i8*
  call void @llvm.memset.p0i8.i32(i8* %15, i8 0, i32 260, i32 4, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %16 = load i32, i32* %retval, align 4
  ret i32 %16
}

; Function Attrs: noinline nounwind
define i32 @rsa_public_decrypt(i8* %out, i32* %out_len, i8* %in, i32 %in_len, %struct.rsa_pk_t* %pk) #0 {
entry:
  %retval = alloca i32, align 4
  %pk.addr = alloca %struct.rsa_pk_t*, align 4
  %in_len.addr = alloca i32, align 4
  %in.addr = alloca i8*, align 4
  %out_len.addr = alloca i32*, align 4
  %out.addr = alloca i8*, align 4
  %status = alloca i32, align 4
  %pkcs_block = alloca [256 x i8], align 1
  %i = alloca i32, align 4
  %modulus_len = alloca i32, align 4
  %pkcs_block_len = alloca i32, align 4
  store %struct.rsa_pk_t* %pk, %struct.rsa_pk_t** %pk.addr, align 4
  store i32 %in_len, i32* %in_len.addr, align 4
  store i8* %in, i8** %in.addr, align 4
  store i32* %out_len, i32** %out_len.addr, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %bits = getelementptr inbounds %struct.rsa_pk_t, %struct.rsa_pk_t* %0, i32 0, i32 0
  %1 = load i32, i32* %bits, align 4
  %add = add i32 %1, 7
  %div = udiv i32 %add, 8
  store i32 %div, i32* %modulus_len, align 4
  %2 = load i32, i32* %in_len.addr, align 4
  %3 = load i32, i32* %modulus_len, align 4
  %cmp = icmp ugt i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 4098, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.rsa_pk_t*, %struct.rsa_pk_t** %pk.addr, align 4
  %5 = load i32, i32* %in_len.addr, align 4
  %6 = load i8*, i8** %in.addr, align 4
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 0
  %call = call i32 @public_block_operation(i8* %arraydecay, i32* %pkcs_block_len, i8* %6, i32 %5, %struct.rsa_pk_t* %4)
  store i32 %call, i32* %status, align 4
  %7 = load i32, i32* %status, align 4
  %cmp1 = icmp ne i32 %7, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %8 = load i32, i32* %status, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %9 = load i32, i32* %pkcs_block_len, align 4
  %10 = load i32, i32* %modulus_len, align 4
  %cmp4 = icmp ne i32 %9, %10
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 4098, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 0
  %11 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %11 to i32
  %cmp7 = icmp ne i32 %conv, 0
  br i1 %cmp7, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end6
  %arrayidx9 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 1
  %12 = load i8, i8* %arrayidx9, align 1
  %conv10 = zext i8 %12 to i32
  %cmp11 = icmp ne i32 %conv10, 1
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %lor.lhs.false, %if.end6
  store i32 4097, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %lor.lhs.false
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end14
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* %modulus_len, align 4
  %sub = sub i32 %14, 1
  %cmp15 = icmp ult i32 %13, %sub
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load i32, i32* %i, align 4
  %arrayidx17 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 %15
  %16 = load i8, i8* %arrayidx17, align 1
  %conv18 = zext i8 %16 to i32
  %cmp19 = icmp ne i32 %conv18, 255
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %for.body
  br label %for.end

if.end22:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end22
  %17 = load i32, i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then21, %for.cond
  %18 = load i32, i32* %i, align 4
  %inc23 = add i32 %18, 1
  store i32 %inc23, i32* %i, align 4
  %arrayidx24 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 %18
  %19 = load i8, i8* %arrayidx24, align 1
  %conv25 = zext i8 %19 to i32
  %cmp26 = icmp ne i32 %conv25, 0
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %for.end
  store i32 4097, i32* %retval, align 4
  br label %return

if.end29:                                         ; preds = %for.end
  %20 = load i32, i32* %modulus_len, align 4
  %21 = load i32, i32* %i, align 4
  %sub30 = sub i32 %20, %21
  %22 = load i32*, i32** %out_len.addr, align 4
  store i32 %sub30, i32* %22, align 4
  %23 = load i32*, i32** %out_len.addr, align 4
  %24 = load i32, i32* %23, align 4
  %add31 = add i32 %24, 11
  %25 = load i32, i32* %modulus_len, align 4
  %cmp32 = icmp ugt i32 %add31, %25
  br i1 %cmp32, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end29
  store i32 4097, i32* %retval, align 4
  br label %return

if.end35:                                         ; preds = %if.end29
  %26 = load i8*, i8** %out.addr, align 4
  %27 = load i32, i32* %i, align 4
  %arrayidx36 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 %27
  %28 = load i32*, i32** %out_len.addr, align 4
  %29 = load i32, i32* %28, align 4
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %26, i8* %arrayidx36, i32 %29, i32 1, i1 false)
  %arraydecay37 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 0
  call void @llvm.memset.p0i8.i32(i8* %arraydecay37, i8 0, i32 256, i32 1, i1 false)
  %30 = load i32, i32* %status, align 4
  store i32 %30, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end35, %if.then34, %if.then28, %if.then13, %if.then5, %if.then2, %if.then
  %31 = load i32, i32* %retval, align 4
  ret i32 %31
}

; Function Attrs: noinline nounwind
define i32 @rsa_private_encrypt(i8* %out, i32* %out_len, i8* %in, i32 %in_len, %struct.rsa_sk_t* %sk) #0 {
entry:
  %retval = alloca i32, align 4
  %sk.addr = alloca %struct.rsa_sk_t*, align 4
  %in_len.addr = alloca i32, align 4
  %in.addr = alloca i8*, align 4
  %out_len.addr = alloca i32*, align 4
  %out.addr = alloca i8*, align 4
  %status = alloca i32, align 4
  %pkcs_block = alloca [256 x i8], align 1
  %i = alloca i32, align 4
  %modulus_len = alloca i32, align 4
  store %struct.rsa_sk_t* %sk, %struct.rsa_sk_t** %sk.addr, align 4
  store i32 %in_len, i32* %in_len.addr, align 4
  store i8* %in, i8** %in.addr, align 4
  store i32* %out_len, i32** %out_len.addr, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %bits = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %0, i32 0, i32 0
  %1 = load i32, i32* %bits, align 4
  %add = add i32 %1, 7
  %div = udiv i32 %add, 8
  store i32 %div, i32* %modulus_len, align 4
  %2 = load i32, i32* %in_len.addr, align 4
  %add1 = add i32 %2, 11
  %3 = load i32, i32* %modulus_len, align 4
  %cmp = icmp ugt i32 %add1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 4098, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 0
  store i8 0, i8* %arrayidx, align 1
  %arrayidx2 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 1
  store i8 1, i8* %arrayidx2, align 1
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* %modulus_len, align 4
  %6 = load i32, i32* %in_len.addr, align 4
  %sub = sub i32 %5, %6
  %sub3 = sub i32 %sub, 1
  %cmp4 = icmp ult i32 %4, %sub3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32, i32* %i, align 4
  %arrayidx5 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 %7
  store i8 -1, i8* %arrayidx5, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, i32* %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load i32, i32* %i, align 4
  %inc6 = add i32 %9, 1
  store i32 %inc6, i32* %i, align 4
  %arrayidx7 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 %9
  store i8 0, i8* %arrayidx7, align 1
  %10 = load i32, i32* %i, align 4
  %arrayidx8 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 %10
  %11 = load i8*, i8** %in.addr, align 4
  %12 = load i32, i32* %in_len.addr, align 4
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %arrayidx8, i8* %11, i32 %12, i32 1, i1 false)
  %13 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %14 = load i32, i32* %modulus_len, align 4
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 0
  %15 = load i32*, i32** %out_len.addr, align 4
  %16 = load i8*, i8** %out.addr, align 4
  %call = call i32 @private_block_operation(i8* %16, i32* %15, i8* %arraydecay, i32 %14, %struct.rsa_sk_t* %13)
  store i32 %call, i32* %status, align 4
  %arraydecay9 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 0
  call void @llvm.memset.p0i8.i32(i8* %arraydecay9, i8 0, i32 256, i32 1, i1 false)
  %17 = load i32, i32* %status, align 4
  store i32 %17, i32* %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %18 = load i32, i32* %retval, align 4
  ret i32 %18
}

; Function Attrs: noinline nounwind
define internal i32 @private_block_operation(i8* %out, i32* %out_len, i8* %in, i32 %in_len, %struct.rsa_sk_t* %sk) #0 {
entry:
  %retval = alloca i32, align 4
  %sk.addr = alloca %struct.rsa_sk_t*, align 4
  %in_len.addr = alloca i32, align 4
  %in.addr = alloca i8*, align 4
  %out_len.addr = alloca i32*, align 4
  %out.addr = alloca i8*, align 4
  %cdigits = alloca i32, align 4
  %ndigits = alloca i32, align 4
  %pdigits = alloca i32, align 4
  %c = alloca [65 x i32], align 4
  %cp = alloca [65 x i32], align 4
  %cq = alloca [65 x i32], align 4
  %dp = alloca [65 x i32], align 4
  %dq = alloca [65 x i32], align 4
  %mp = alloca [65 x i32], align 4
  %mq = alloca [65 x i32], align 4
  %n = alloca [65 x i32], align 4
  %p = alloca [65 x i32], align 4
  %q = alloca [65 x i32], align 4
  %q_inv = alloca [65 x i32], align 4
  %t = alloca [65 x i32], align 4
  store %struct.rsa_sk_t* %sk, %struct.rsa_sk_t** %sk.addr, align 4
  store i32 %in_len, i32* %in_len.addr, align 4
  store i8* %in, i8** %in.addr, align 4
  store i32* %out_len, i32** %out_len.addr, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load i32, i32* %in_len.addr, align 4
  %1 = load i8*, i8** %in.addr, align 4
  %arraydecay = getelementptr inbounds [65 x i32], [65 x i32]* %c, i32 0, i32 0
  call void @bn_decode(i32* %arraydecay, i32 65, i8* %1, i32 %0)
  %2 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %modulus = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %2, i32 0, i32 1
  %arraydecay1 = getelementptr inbounds [256 x i8], [256 x i8]* %modulus, i32 0, i32 0
  %arraydecay2 = getelementptr inbounds [65 x i32], [65 x i32]* %n, i32 0, i32 0
  call void @bn_decode(i32* %arraydecay2, i32 65, i8* %arraydecay1, i32 256)
  %3 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %prime1 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %3, i32 0, i32 4
  %arraydecay3 = getelementptr inbounds [128 x i8], [128 x i8]* %prime1, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  call void @bn_decode(i32* %arraydecay4, i32 65, i8* %arraydecay3, i32 128)
  %4 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %prime2 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %4, i32 0, i32 5
  %arraydecay5 = getelementptr inbounds [128 x i8], [128 x i8]* %prime2, i32 0, i32 0
  %arraydecay6 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  call void @bn_decode(i32* %arraydecay6, i32 65, i8* %arraydecay5, i32 128)
  %5 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %prime_exponent1 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %5, i32 0, i32 6
  %arraydecay7 = getelementptr inbounds [128 x i8], [128 x i8]* %prime_exponent1, i32 0, i32 0
  %arraydecay8 = getelementptr inbounds [65 x i32], [65 x i32]* %dp, i32 0, i32 0
  call void @bn_decode(i32* %arraydecay8, i32 65, i8* %arraydecay7, i32 128)
  %6 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %prime_exponent2 = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %6, i32 0, i32 7
  %arraydecay9 = getelementptr inbounds [128 x i8], [128 x i8]* %prime_exponent2, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [65 x i32], [65 x i32]* %dq, i32 0, i32 0
  call void @bn_decode(i32* %arraydecay10, i32 65, i8* %arraydecay9, i32 128)
  %7 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %coefficient = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %7, i32 0, i32 8
  %arraydecay11 = getelementptr inbounds [128 x i8], [128 x i8]* %coefficient, i32 0, i32 0
  %arraydecay12 = getelementptr inbounds [65 x i32], [65 x i32]* %q_inv, i32 0, i32 0
  call void @bn_decode(i32* %arraydecay12, i32 65, i8* %arraydecay11, i32 128)
  %arraydecay13 = getelementptr inbounds [65 x i32], [65 x i32]* %c, i32 0, i32 0
  %call = call i32 @bn_digits(i32* %arraydecay13, i32 65)
  store i32 %call, i32* %cdigits, align 4
  %arraydecay14 = getelementptr inbounds [65 x i32], [65 x i32]* %n, i32 0, i32 0
  %call15 = call i32 @bn_digits(i32* %arraydecay14, i32 65)
  store i32 %call15, i32* %ndigits, align 4
  %arraydecay16 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %call17 = call i32 @bn_digits(i32* %arraydecay16, i32 65)
  store i32 %call17, i32* %pdigits, align 4
  %8 = load i32, i32* %ndigits, align 4
  %arraydecay18 = getelementptr inbounds [65 x i32], [65 x i32]* %n, i32 0, i32 0
  %arraydecay19 = getelementptr inbounds [65 x i32], [65 x i32]* %c, i32 0, i32 0
  %call20 = call i32 @bn_cmp(i32* %arraydecay19, i32* %arraydecay18, i32 %8)
  %cmp = icmp sge i32 %call20, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 4097, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %9 = load i32, i32* %pdigits, align 4
  %arraydecay21 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %10 = load i32, i32* %cdigits, align 4
  %arraydecay22 = getelementptr inbounds [65 x i32], [65 x i32]* %c, i32 0, i32 0
  %arraydecay23 = getelementptr inbounds [65 x i32], [65 x i32]* %cp, i32 0, i32 0
  call void @bn_mod(i32* %arraydecay23, i32* %arraydecay22, i32 %10, i32* %arraydecay21, i32 %9)
  %11 = load i32, i32* %pdigits, align 4
  %arraydecay24 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %12 = load i32, i32* %cdigits, align 4
  %arraydecay25 = getelementptr inbounds [65 x i32], [65 x i32]* %c, i32 0, i32 0
  %arraydecay26 = getelementptr inbounds [65 x i32], [65 x i32]* %cq, i32 0, i32 0
  call void @bn_mod(i32* %arraydecay26, i32* %arraydecay25, i32 %12, i32* %arraydecay24, i32 %11)
  %13 = load i32, i32* %pdigits, align 4
  %arraydecay27 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %14 = load i32, i32* %pdigits, align 4
  %arraydecay28 = getelementptr inbounds [65 x i32], [65 x i32]* %dp, i32 0, i32 0
  %arraydecay29 = getelementptr inbounds [65 x i32], [65 x i32]* %cp, i32 0, i32 0
  %arraydecay30 = getelementptr inbounds [65 x i32], [65 x i32]* %mp, i32 0, i32 0
  call void @bn_mod_exp(i32* %arraydecay30, i32* %arraydecay29, i32* %arraydecay28, i32 %14, i32* %arraydecay27, i32 %13)
  %15 = load i32, i32* %ndigits, align 4
  %arraydecay31 = getelementptr inbounds [65 x i32], [65 x i32]* %mq, i32 0, i32 0
  call void @bn_assign_zero(i32* %arraydecay31, i32 %15)
  %16 = load i32, i32* %pdigits, align 4
  %arraydecay32 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %17 = load i32, i32* %pdigits, align 4
  %arraydecay33 = getelementptr inbounds [65 x i32], [65 x i32]* %dq, i32 0, i32 0
  %arraydecay34 = getelementptr inbounds [65 x i32], [65 x i32]* %cq, i32 0, i32 0
  %arraydecay35 = getelementptr inbounds [65 x i32], [65 x i32]* %mq, i32 0, i32 0
  call void @bn_mod_exp(i32* %arraydecay35, i32* %arraydecay34, i32* %arraydecay33, i32 %17, i32* %arraydecay32, i32 %16)
  %18 = load i32, i32* %pdigits, align 4
  %arraydecay36 = getelementptr inbounds [65 x i32], [65 x i32]* %mq, i32 0, i32 0
  %arraydecay37 = getelementptr inbounds [65 x i32], [65 x i32]* %mp, i32 0, i32 0
  %call38 = call i32 @bn_cmp(i32* %arraydecay37, i32* %arraydecay36, i32 %18)
  %cmp39 = icmp sge i32 %call38, 0
  br i1 %cmp39, label %if.then40, label %if.else

if.then40:                                        ; preds = %if.end
  %19 = load i32, i32* %pdigits, align 4
  %arraydecay41 = getelementptr inbounds [65 x i32], [65 x i32]* %mq, i32 0, i32 0
  %arraydecay42 = getelementptr inbounds [65 x i32], [65 x i32]* %mp, i32 0, i32 0
  %arraydecay43 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %call44 = call i32 @bn_sub(i32* %arraydecay43, i32* %arraydecay42, i32* %arraydecay41, i32 %19)
  br label %if.end53

if.else:                                          ; preds = %if.end
  %20 = load i32, i32* %pdigits, align 4
  %arraydecay45 = getelementptr inbounds [65 x i32], [65 x i32]* %mp, i32 0, i32 0
  %arraydecay46 = getelementptr inbounds [65 x i32], [65 x i32]* %mq, i32 0, i32 0
  %arraydecay47 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %call48 = call i32 @bn_sub(i32* %arraydecay47, i32* %arraydecay46, i32* %arraydecay45, i32 %20)
  %21 = load i32, i32* %pdigits, align 4
  %arraydecay49 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay50 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %arraydecay51 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %call52 = call i32 @bn_sub(i32* %arraydecay51, i32* %arraydecay50, i32* %arraydecay49, i32 %21)
  br label %if.end53

if.end53:                                         ; preds = %if.else, %if.then40
  %22 = load i32, i32* %pdigits, align 4
  %arraydecay54 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %arraydecay55 = getelementptr inbounds [65 x i32], [65 x i32]* %q_inv, i32 0, i32 0
  %arraydecay56 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay57 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_mod_mul(i32* %arraydecay57, i32* %arraydecay56, i32* %arraydecay55, i32* %arraydecay54, i32 %22)
  %23 = load i32, i32* %pdigits, align 4
  %arraydecay58 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %arraydecay59 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay60 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  call void @bn_mul(i32* %arraydecay60, i32* %arraydecay59, i32* %arraydecay58, i32 %23)
  %24 = load i32, i32* %ndigits, align 4
  %arraydecay61 = getelementptr inbounds [65 x i32], [65 x i32]* %mq, i32 0, i32 0
  %arraydecay62 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %arraydecay63 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %call64 = call i32 @bn_add(i32* %arraydecay63, i32* %arraydecay62, i32* %arraydecay61, i32 %24)
  %25 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %bits = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %25, i32 0, i32 0
  %26 = load i32, i32* %bits, align 4
  %add = add i32 %26, 7
  %div = udiv i32 %add, 8
  %27 = load i32*, i32** %out_len.addr, align 4
  store i32 %div, i32* %27, align 4
  %28 = load i32, i32* %ndigits, align 4
  %arraydecay65 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %29 = load i32*, i32** %out_len.addr, align 4
  %30 = load i32, i32* %29, align 4
  %31 = load i8*, i8** %out.addr, align 4
  call void @bn_encode(i8* %31, i32 %30, i32* %arraydecay65, i32 %28)
  %arraydecay66 = getelementptr inbounds [65 x i32], [65 x i32]* %c, i32 0, i32 0
  %32 = bitcast i32* %arraydecay66 to i8*
  call void @llvm.memset.p0i8.i32(i8* %32, i8 0, i32 260, i32 4, i1 false)
  %arraydecay67 = getelementptr inbounds [65 x i32], [65 x i32]* %cp, i32 0, i32 0
  %33 = bitcast i32* %arraydecay67 to i8*
  call void @llvm.memset.p0i8.i32(i8* %33, i8 0, i32 260, i32 4, i1 false)
  %arraydecay68 = getelementptr inbounds [65 x i32], [65 x i32]* %cq, i32 0, i32 0
  %34 = bitcast i32* %arraydecay68 to i8*
  call void @llvm.memset.p0i8.i32(i8* %34, i8 0, i32 260, i32 4, i1 false)
  %arraydecay69 = getelementptr inbounds [65 x i32], [65 x i32]* %dp, i32 0, i32 0
  %35 = bitcast i32* %arraydecay69 to i8*
  call void @llvm.memset.p0i8.i32(i8* %35, i8 0, i32 260, i32 4, i1 false)
  %arraydecay70 = getelementptr inbounds [65 x i32], [65 x i32]* %dq, i32 0, i32 0
  %36 = bitcast i32* %arraydecay70 to i8*
  call void @llvm.memset.p0i8.i32(i8* %36, i8 0, i32 260, i32 4, i1 false)
  %arraydecay71 = getelementptr inbounds [65 x i32], [65 x i32]* %mp, i32 0, i32 0
  %37 = bitcast i32* %arraydecay71 to i8*
  call void @llvm.memset.p0i8.i32(i8* %37, i8 0, i32 260, i32 4, i1 false)
  %arraydecay72 = getelementptr inbounds [65 x i32], [65 x i32]* %mq, i32 0, i32 0
  %38 = bitcast i32* %arraydecay72 to i8*
  call void @llvm.memset.p0i8.i32(i8* %38, i8 0, i32 260, i32 4, i1 false)
  %arraydecay73 = getelementptr inbounds [65 x i32], [65 x i32]* %p, i32 0, i32 0
  %39 = bitcast i32* %arraydecay73 to i8*
  call void @llvm.memset.p0i8.i32(i8* %39, i8 0, i32 260, i32 4, i1 false)
  %arraydecay74 = getelementptr inbounds [65 x i32], [65 x i32]* %q, i32 0, i32 0
  %40 = bitcast i32* %arraydecay74 to i8*
  call void @llvm.memset.p0i8.i32(i8* %40, i8 0, i32 260, i32 4, i1 false)
  %arraydecay75 = getelementptr inbounds [65 x i32], [65 x i32]* %q_inv, i32 0, i32 0
  %41 = bitcast i32* %arraydecay75 to i8*
  call void @llvm.memset.p0i8.i32(i8* %41, i8 0, i32 260, i32 4, i1 false)
  %arraydecay76 = getelementptr inbounds [65 x i32], [65 x i32]* %t, i32 0, i32 0
  %42 = bitcast i32* %arraydecay76 to i8*
  call void @llvm.memset.p0i8.i32(i8* %42, i8 0, i32 260, i32 4, i1 false)
  store i32 0, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end53, %if.then
  %43 = load i32, i32* %retval, align 4
  ret i32 %43
}

; Function Attrs: noinline nounwind
define i32 @rsa_private_decrypt(i8* %out, i32* %out_len, i8* %in, i32 %in_len, %struct.rsa_sk_t* %sk) #0 {
entry:
  %retval = alloca i32, align 4
  %sk.addr = alloca %struct.rsa_sk_t*, align 4
  %in_len.addr = alloca i32, align 4
  %in.addr = alloca i8*, align 4
  %out_len.addr = alloca i32*, align 4
  %out.addr = alloca i8*, align 4
  %status = alloca i32, align 4
  %pkcs_block = alloca [256 x i8], align 1
  %i = alloca i32, align 4
  %modulus_len = alloca i32, align 4
  %pkcs_block_len = alloca i32, align 4
  store %struct.rsa_sk_t* %sk, %struct.rsa_sk_t** %sk.addr, align 4
  store i32 %in_len, i32* %in_len.addr, align 4
  store i8* %in, i8** %in.addr, align 4
  store i32* %out_len, i32** %out_len.addr, align 4
  store i8* %out, i8** %out.addr, align 4
  %0 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %bits = getelementptr inbounds %struct.rsa_sk_t, %struct.rsa_sk_t* %0, i32 0, i32 0
  %1 = load i32, i32* %bits, align 4
  %add = add i32 %1, 7
  %div = udiv i32 %add, 8
  store i32 %div, i32* %modulus_len, align 4
  %2 = load i32, i32* %in_len.addr, align 4
  %3 = load i32, i32* %modulus_len, align 4
  %cmp = icmp ugt i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 4098, i32* %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.rsa_sk_t*, %struct.rsa_sk_t** %sk.addr, align 4
  %5 = load i32, i32* %in_len.addr, align 4
  %6 = load i8*, i8** %in.addr, align 4
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 0
  %call = call i32 @private_block_operation(i8* %arraydecay, i32* %pkcs_block_len, i8* %6, i32 %5, %struct.rsa_sk_t* %4)
  store i32 %call, i32* %status, align 4
  %7 = load i32, i32* %status, align 4
  %cmp1 = icmp ne i32 %7, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %8 = load i32, i32* %status, align 4
  store i32 %8, i32* %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %9 = load i32, i32* %pkcs_block_len, align 4
  %10 = load i32, i32* %modulus_len, align 4
  %cmp4 = icmp ne i32 %9, %10
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  store i32 4098, i32* %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  %arrayidx = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 0
  %11 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %11 to i32
  %cmp7 = icmp ne i32 %conv, 0
  br i1 %cmp7, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end6
  %arrayidx9 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 1
  %12 = load i8, i8* %arrayidx9, align 1
  %conv10 = zext i8 %12 to i32
  %cmp11 = icmp ne i32 %conv10, 2
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %lor.lhs.false, %if.end6
  store i32 4097, i32* %retval, align 4
  br label %return

if.end14:                                         ; preds = %lor.lhs.false
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end14
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* %modulus_len, align 4
  %sub = sub i32 %14, 1
  %cmp15 = icmp ult i32 %13, %sub
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load i32, i32* %i, align 4
  %arrayidx17 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 %15
  %16 = load i8, i8* %arrayidx17, align 1
  %conv18 = zext i8 %16 to i32
  %cmp19 = icmp eq i32 %conv18, 0
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %for.body
  br label %for.end

if.end22:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end22
  %17 = load i32, i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then21, %for.cond
  %18 = load i32, i32* %i, align 4
  %inc23 = add i32 %18, 1
  store i32 %inc23, i32* %i, align 4
  %19 = load i32, i32* %i, align 4
  %20 = load i32, i32* %modulus_len, align 4
  %cmp24 = icmp uge i32 %19, %20
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %for.end
  store i32 4097, i32* %retval, align 4
  br label %return

if.end27:                                         ; preds = %for.end
  %21 = load i32, i32* %modulus_len, align 4
  %22 = load i32, i32* %i, align 4
  %sub28 = sub i32 %21, %22
  %23 = load i32*, i32** %out_len.addr, align 4
  store i32 %sub28, i32* %23, align 4
  %24 = load i32*, i32** %out_len.addr, align 4
  %25 = load i32, i32* %24, align 4
  %add29 = add i32 %25, 11
  %26 = load i32, i32* %modulus_len, align 4
  %cmp30 = icmp ugt i32 %add29, %26
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end27
  store i32 4097, i32* %retval, align 4
  br label %return

if.end33:                                         ; preds = %if.end27
  %27 = load i8*, i8** %out.addr, align 4
  %28 = load i32, i32* %i, align 4
  %arrayidx34 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 %28
  %29 = load i32*, i32** %out_len.addr, align 4
  %30 = load i32, i32* %29, align 4
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %27, i8* %arrayidx34, i32 %30, i32 1, i1 false)
  %arraydecay35 = getelementptr inbounds [256 x i8], [256 x i8]* %pkcs_block, i32 0, i32 0
  call void @llvm.memset.p0i8.i32(i8* %arraydecay35, i8 0, i32 256, i32 1, i1 false)
  %31 = load i32, i32* %status, align 4
  store i32 %31, i32* %retval, align 4
  br label %return

return:                                           ; preds = %if.end33, %if.then32, %if.then26, %if.then13, %if.then5, %if.then2, %if.then
  %32 = load i32, i32* %retval, align 4
  ret i32 %32
}

attributes #0 = { noinline nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="pentium4" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="pentium4" "target-features"="+fxsr,+mmx,+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.ident = !{!0, !0, !0, !0, !0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 3.8.0 (branches/release_38)"}
!1 = !{i32 6, !"Linker Options", !2}
!2 = !{!3, !4, !5, !6, !7, !8}
!3 = !{!"/DEFAULTLIB:msvcrt.lib"}
!4 = !{!"/DEFAULTLIB:oldnames.lib"}
!5 = !{!"/DEFAULTLIB:msvcprtd.lib"}
!6 = !{!"/FAILIFMISMATCH:\22_MSC_VER=1600\22"}
!7 = !{!"/FAILIFMISMATCH:\22_ITERATOR_DEBUG_LEVEL=2\22"}
!8 = !{!"/DEFAULTLIB:uuid.lib"}
